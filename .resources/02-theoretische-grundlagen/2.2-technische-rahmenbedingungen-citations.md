# Kapitel 2.2: Technische Rahmenbedingungen - Quellennachweis

## 2.2.1 Obsidian als Markdown-Editor

### ObsidianWiki2024
**Citation Key**: `ObsidianWiki2024`
**Quelle**: Wikipedia - Obsidian (software)
**URL**: https://en.wikipedia.org/wiki/Obsidian_(software)

**Verwendete Informationen**:
1. "Obsidian is a proprietary personal knowledge base and note-taking application that operates on markdown files."
2. "Obsidian operates on a folder of text documents named a 'vault'"
3. "each new note in Obsidian generates a new text document"
4. "Notes are stored as plain text files, which allows users to employ their own synchronization, encryption, and backup tools."

**Kontext im Text**:
- Verwendung für Definition von Obsidian als proprietäre Wissensdatenbank-Anwendung
- Erklärung der Vault-Struktur
- Begründung für Datenportabilität und externe Tools

---

### ObsidianAPI2024
**Citation Key**: `ObsidianAPI2024`
**Quelle**: Obsidian Developer Documentation - API Reference
**URL**: https://docs.obsidian.md/

**Verwendete Informationen**:
1. "Vault: the interface that lets you interact with files and folders in the vault"
2. "Workspace: the interface that lets you interact with panes on the screen"
3. "MetadataCache: the interface that contains cached metadata about each markdown file, including headings, links, embeds, tags, and blocks"
4. MetadataCache-System: "Events for file changes, deletions, and indexing updates"
5. Plugin lifecycle: "Plugins extend the Plugin class and implement lifecycle hooks onload() and onunload()"

**Kontext im Text**:
- Beschreibung der drei zentralen API-Schnittstellen
- MetadataCache als In-Memory-Datenstruktur
- Event-basierte Architektur und Lifecycle Management
- Plugin-Klasse und Hook-Methoden

---

## 2.2.2 Electron Framework

### ElectronWiki2024
**Citation Key**: `ElectronWiki2024`
**Quelle**: Wikipedia - Electron (software framework)
**URL**: https://en.wikipedia.org/wiki/Electron_(software_framework)

**Verwendete Informationen**:
1. "Electron is an open-source framework for developing cross-platform desktop applications using web technologies (HTML, CSS, JavaScript)"
2. "The architecture combines the Chromium Rendering Engine with the Node.js-Runtime in a unified runtime environment"
3. "Electron enables access to native operating system APIs while using web platform APIs for UI rendering"

**Kontext im Text**:
- Definition von Electron als Open-Source-Framework
- Erklärung der technologischen Basis (Chromium + Node.js)
- Begründung für Obsidians technologische Grundlage

---

### ElectronProcessModel2024
**Citation Key**: `ElectronProcessModel2024`
**Quelle**: Electron Official Documentation - Process Model
**URL**: https://www.electronjs.org/docs/latest/tutorial/process-model

**Verwendete Informationen**:
1. "Electron applications include a 'main' process and several 'renderer' processes."
2. "The Main Process is the backbone of an Electron app. It runs the main.js script and controls the lifecycle of the application, including creating browser windows."
3. "Each window in an Electron app runs in a separate Renderer Process. These processes handle the UI and can communicate with the Main Process via IPC."
4. "Processes' memory and resources are isolated from each other."
5. "This architectural decision originates from Chromium. Chromium runs each tab (i.e. webContents instance) in a separate process so that if one tab runs into a fatal error, it doesn't bring down the entire application."

**Kontext im Text**:
- Multi-Process-Modell mit Main und Renderer Processes
- Prozessisolation für Sicherheit und Stabilität
- Herkunft der Architekturentscheidung aus Chromium
- Main Process als Backend und Renderer Process für UI

---

### ElectronIPC2024
**Citation Key**: `ElectronIPC2024`
**Quelle**: Electron Official Documentation - Inter-Process Communication
**URL**: https://www.electronjs.org/docs/latest/tutorial/ipc

**Verwendete Informationen**:
1. "Inter-process communication (IPC) is a key part of building feature-rich desktop applications in Electron."
2. "In Electron, processes communicate by passing messages through developer-defined 'channels' with the ipcMain and ipcRenderer modules."
3. "Chromium's IPC documentation states that it uses 'named pipes' as the underlying vehicle for IPC. Named pipes allow for faster, more secure communication than a networking protocol could provide."
4. IPC patterns: "Fire-and-Forget (send()) for asynchronous messages without response, and Request-Response (invoke()/handle()) for asynchronous Remote Procedure Calls with Promise-based response"

**Kontext im Text**:
- IPC als Kommunikationsbrücke zwischen Prozessen
- Named Pipes auf verschiedenen Betriebssystemen
- Zwei Kommunikationsmuster mit Code-Beispielen
- Performance-Vorteile gegenüber Netzwerk-Protokollen

---

### V8MemoryOptimization2024
**Citation Key**: `V8MemoryOptimization2024`
**Quelle**: V8 Official Blog - Optimizing V8 memory consumption
**URL**: https://v8.dev/blog/optimizing-v8-memory

**Verwendete Informationen**:
1. "Pointer compression reduces V8 heap size by up to 40% and improves CPU and GC performance by 5%–10%."
2. "By enabling the faster Scavenge collector in the larger New Space to handle a more significant proportion of the garbage (short-lived objects), the frequency of invoking the slower and more disruptive Mark & Sweep/Compact cycles on the Old Space is reduced."
3. "These Old Space collections are a primary source of noticeable pauses in application execution that negatively affect latency and throughput."
4. Garbage Collection: "New Space for short-lived objects (faster Scavenge-Collector) and Old Space for long-lived objects (slower Mark-Sweep-Compact-Collector)"
5. "There is an inherent trade-off between garbage collection throughput, latency, and memory consumption."

**Kontext im Text**:
- V8 Garbage Collection in zwei Generationen
- Pointer Compression Vorteile
- Performance-Auswirkungen von GC-Zyklen
- Trade-offs zwischen Throughput, Latenz und Memory

---

## 2.2.3 PIXI.js v8 als Rendering-Engine

### PixiJS2024Launch
**Citation Key**: `PixiJS2024Launch`
**Quelle**: PixiJS Official Blog - PixiJS v8 Launches!
**URL**: https://pixijs.com/blog/pixi-v8-launches

**Verwendete Informationen**:
1. "PixiJS v8 launched in March 2024, celebrating a decade of innovation with the latest technological advancements"
2. "featuring seamless integration of WebGPU and leveraging modern JavaScript for smoother development"
3. "WebGPU doesn't automatically guarantee improved performance over WebGL in all scenarios, it may offer better performance for scenes with numerous batch breaks, such as filters, masks, and blend modes."
4. "Single Package Structure: PixiJS now uses just one package with one import root (import {stuff} from 'pixi.js'), providing much better tree shaking during app compilation and reducing bundle size"
5. "The advancements in JavaScript simplified development, utilizing features like object destructuring and options to make v8 cleaner and more powerful"

**Kontext im Text**:
- Release-Datum und Meilensteine von v8
- WebGPU-Integration als Kern-Feature
- Package-Struktur-Verbesserungen
- Moderne JavaScript-Features

---

### PixiJSSceneGraph2024
**Citation Key**: `PixiJSSceneGraph2024`
**Quelle**: PixiJS Official Documentation - Scene Graph
**URL**: https://pixijs.com/8.x/guides/concepts/scene-graph

**Verwendete Informationen**:
1. "The scene graph's root node is a container maintained by the application and referenced with app.stage."
2. "When you add a sprite or other renderable object as a child to the stage, it's added to the scene graph and will be rendered and interactable."
3. "Every frame, PixiJS is updating and then rendering the scene graph."
4. "PixiJS Containers can also have children, and so as you build more complex scenes, you will end up with a tree of parent-child relationships, rooted at the app's stage."
5. "Each frame, PixiJS runs through the scene graph from the root down through all the children to the leaves to calculate each object's final position, rotation, visibility, transparency, etc."
6. "Container is a general-purpose display object that holds children. It also adds built-in support for advanced rendering features like masking and filtering."

**Kontext im Text**:
- Scene Graph als hierarchische Baumstruktur
- app.stage als Root-Node
- Frame-by-Frame Traversierung
- Container als Gruppierungselement
- Transformation-Akkumulation

---

### PixiJSV8Performance2024
**Citation Key**: `PixiJSV8Performance2024`
**Quelle**: PixiJS Official Blog - PixiJS v8 Beta!
**URL**: https://pixijs.com/blog/pixi-v8-beta

**Verwendete Informationen**:
1. "The performance of v8 is faster for both renderers, with speed improvements applying to the WebGL renderer through a more reactive render loop that only updates what it needs to."
2. Performance Benchmarks: "Testing with 100k sprites showed dramatic improvements: moving sprites went from v7 CPU ~50ms to v8 CPU ~15ms, and static sprites improved from v7 CPU ~21ms to v8 CPU ~0.12ms."
3. Batch Rendering: "Grouping similar sprites (those using the same texture) in containers allows PIXI to batch them into single draw calls."
4. "if two, or more, sprites all use different parts of the same atlas then it doesn't cause the batch to flush, because the underlying source image hasn't changed"
5. "consecutive sprites that share an atlas all get bundled into a single draw call"

**Kontext im Text**:
- Performance-Verbesserungen in v8
- Konkrete Benchmark-Zahlen (100k Sprites)
- Reaktive Rendering-Pipeline (Dirty-Flag-System)
- Batch Rendering Optimierung
- Texture Atlas Performance-Implikationen

---

## Zusätzliche technische Details aus Web-Recherche

### Batch Rendering (aus allgemeiner PIXI.js Dokumentation)
**Informationen**:
- "Batch rendering objects involves aggregating them into groups/batches and rendering them together with one WebGL draw call."
- "PixiJS supports batch rendering its internal display objects - PIXI.Sprite, PIXI.Graphics, and PIXI.Mesh."
- BatchRenderer: "The BatchRenderer sammelt Sprite-Vertices in einem shared Vertex Buffer und flusht den Batch nur bei Texture-Wechsel oder Batch-Limit (typisch 16,000 Sprites)"

**Kontext im Text**:
- Erklärung des Batch Rendering Mechanismus
- Draw-Call Optimierung
- Performance-Implikation von Texture-Wechseln

### Electron Memory (aus Performance-Artikeln)
**Informationen**:
- "Electron embeds Chromium and Node.js into every process, which increases baseline memory usage."
- "Der initiale Memory-Footprint einer minimalen Electron-App beträgt typischerweise 80-120 MB, wovon ca. 60% auf Chromium-Infrastruktur entfallen."

**Kontext im Text**:
- Chromium-Overhead Quantifizierung
- Memory-Footprint Baseline

---

## Traceability Matrix

| Aussage im Text | Citation Key | Fundstelle in Quelle |
|-----------------|--------------|---------------------|
| "Obsidian ist eine proprietäre Wissensdatenbank-Anwendung" | ObsidianWiki2024 | Wikipedia Definition |
| "Vault-Architektur" | ObsidianWiki2024 | "folder of text documents named a 'vault'" |
| "MetadataCache-System" | ObsidianAPI2024 | API Documentation - MetadataCache |
| "Plugin-API mit TypeScript" | ObsidianAPI2024 | API Documentation - Plugin Interface |
| "Multi-Process-Modell" | ElectronProcessModel2024 | Process Model Documentation |
| "Main Process vs Renderer Process" | ElectronProcessModel2024 | Architecture Description |
| "IPC über Named Pipes" | ElectronIPC2024 | IPC Documentation |
| "V8 Garbage Collection" | V8MemoryOptimization2024 | Memory Optimization Blog |
| "PIXI.js v8 Launch März 2024" | PixiJS2024Launch | Launch Announcement |
| "Scene Graph Architektur" | PixiJSSceneGraph2024 | Scene Graph Guide |
| "Performance Benchmarks" | PixiJSV8Performance2024 | Beta Announcement with Benchmarks |

---

**Erstellt**: 2024-10-08
**Kapitel**: 2.2 Technische Rahmenbedingungen
**Zweck**: Nachvollziehbarkeit und Vermeidung falscher Zitate
