# 2.1.1 Obsidian als Markdown-Editor

## Kontext und Planung

### Kernthema
Technische Einführung in Obsidian als Plattform für Plugin-Entwicklung mit Fokus auf Architektur und Performance-relevante Aspekte.

### Ziel des Abschnitts
Grundlegendes Verständnis von Obsidians Architektur schaffen, um später die Performance-Herausforderungen von Plugins einordnen zu können.

## Inhaltliche Struktur

### Obsidian Overview (1-2 Absätze)
- Second-Brain / Knowledge Management Tool
- Markdown-basiert mit lokalem Vault-System
- Plugin-Ökosystem als Kernfeature
- Marktposition und Nutzerbasis

### Technische Architektur (2-3 Absätze)
**Core Components:**
- **Vault System**: Lokale Markdown-Dateien als Datenbasis
- **Rendering Engine**: Markdown zu HTML/Preview
- **Plugin API**: Erweiterungspunkte und Hooks
- **Workspace**: View-Management und Layout

**Performance-relevante Aspekte:**
- File System Watcher für Live-Updates
- DOM-basiertes Rendering
- Event-System für Plugin-Kommunikation
- Cache-Layer für schnellen Zugriff

### Plugin-System (2-3 Absätze)
**API-Capabilities:**
- View Registration (Custom Views)
- Command Palette Integration
- Event Subscription System
- Settings Management
- File I/O Operations
- Custom Rendering

**Plugin Lifecycle:**
```typescript
class Plugin {
  onload(): void    // Initialisierung
  onunload(): void  // Cleanup
  registerView()    // Custom Views
  registerEvent()   // Event Handling
}
```

### Performance-Charakteristika (1-2 Absätze)
**Vorteile:**
- Effizientes File-Caching
- Lazy Loading von Inhalten
- Inkrementelles Rendering

**Herausforderungen:**
- Shared Process für alle Plugins
- DOM-Manipulation Overhead
- Memory-Management bei vielen Plugins
- Event-Loop Blocking

### Integration mit Electron (1 Absatz)
- Main Process vs Renderer Process
- IPC-Kommunikation
- Native File System Access
- WebView Isolation

## Code-Beispiele und Konzepte

### Plugin-Grundstruktur
```typescript
import { Plugin, PluginManifest, App } from 'obsidian';

export default class MyPlugin extends Plugin {
  settings: MyPluginSettings;

  async onload() {
    // Plugin-Initialisierung
    await this.loadSettings();
    this.registerView(/* ... */);
    this.addCommand(/* ... */);
  }
}
```

### Performance-kritische APIs
- `registerMarkdownPostProcessor`: DOM-Manipulation
- `registerView`: Custom Rendering
- `workspace.getLeaf()`: View-Management
- `vault.read()`: File I/O

## Relevanz für Atlas VTT

### Möglichkeiten
- Custom View für VTT-Interface
- Vault für Map/Asset-Storage
- Command Palette für Quick Actions
- Settings für Konfiguration

### Constraints
- Kein direkter WebGL-Zugriff über API
- DOM-basierte View-Integration
- Memory-Sharing mit anderen Plugins
- File-basierte Persistierung

## Literatur und Quellen

### Primärquellen
- [ ] Obsidian API Documentation
- [ ] Obsidian Developer Portal
- [ ] GitHub: Obsidian Sample Plugin

### Sekundärquellen
- [ ] Plugin Development Guides
- [ ] Performance Best Practices
- [ ] Community Forums/Discord

### Akademische Quellen
- [ ] Knowledge Management Systems
- [ ] Plugin Architecture Patterns
- [ ] Markdown Processing Performance

## Schreibnotizen

### Wichtige Begriffe
- Vault: Lokaler Ordner mit Markdown-Dateien
- Workspace: UI-Layout und View-Management
- Leaf: Container für Views
- Modal: Popup-Dialoge
- Command: Ausführbare Aktionen

### Abgrenzung
- Fokus auf technische Aspekte
- Keine Feature-Auflistung
- Performance-Relevanz betonen
- Plugin-Perspektive einnehmen

### Zitate benötigt für
- Nutzerzahlen/Marktanteil
- Performance-Benchmarks
- Architektur-Entscheidungen
- API-Limitierungen

## Verbindung zu anderen Kapiteln
- → 2.1.2: Electron als Basis
- → 2.2.2: Plugin-Architekturen allgemein
- → 3.1: Anforderungen an Atlas VTT
- → 3.2: Systemdesign basierend auf Obsidian-API

## TODO beim Schreiben
- [ ] Aktuelle Obsidian-Version referenzieren
- [ ] Code-Beispiele aus Atlas VTT einbinden
- [ ] Performance-Metriken von Obsidian recherchieren
- [ ] API-Limitierungen konkret benennen
- [ ] Community-Plugins als Vergleich