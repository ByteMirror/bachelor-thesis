# 3.1.2 Nicht-funktionale Anforderungen

**Datum**: 2025-01-24
**Status**: Planung abgeschlossen
**Ziel-Seitenzahl**: 1.0-1.5 Seiten

---

## <¯ Kontext und Kernbotschaft

**Kernbotschaft**: Die nicht-funktionalen Anforderungen von Atlas VTT werden durch Performance-Ziele (30+ FPS), Plattform-Constraints (Obsidian/Electron) und Wartbarkeits-Prinzipien (Single Responsibility, Modularität) definiert. Diese Anforderungen sind messbar und wissenschaftlich fundiert.

**Wissenschaftliche Herangehensweise**:
- Performance-Metriken basieren auf Industry Standards (60 FPS Target)
- Plattform-Constraints aus Obsidian/Electron-Architektur abgeleitet
- Wartbarkeits-Metriken aus Software Engineering Best Practices
- Quantifizierbare Ziele (FPS, Bundle Size, Memory Usage)

---

## =Ý Inhaltliche Struktur

### 1. Performance-Anforderungen (0.4 Seiten)

**Motivation**:
- VTTs müssen flüssige Interaktionen ermöglichen (Drag & Drop bei 60 FPS)
- Desktop-Anwendungen haben höhere Performance-Erwartungen als Web-Apps
- Große Maps (4096×4096 px) und viele Tokens (50-100+) sind Standard-Szenarien

**Anforderungen**:

| ID | Metrik | Ziel | Testszena rio | Begründung |
|----|--------|------|---------------|------------|
| NF1.1 | Frame Rate | e30 FPS | 50 Tokens auf 2048×2048 Map | Flüssige Interaktionen |
| NF1.2 | Frame Rate (Ideal) | e60 FPS | Standard-Szenarien | Desktop-Standard |
| NF1.3 | Interaction Latency | <100 ms | Drag & Drop Token | Responsive UI |
| NF1.4 | Map Load Time | <2 s | 4096×4096 Map-Loading | User Experience |
| NF1.5 | Memory Footprint | <500 MB | 100 Tokens, 10 Maps loaded | Electron Memory Limits |

**Industry Benchmarks**:
- **Foundry VTT**: 60 FPS bei 50+ Tokens (Hardware-accelerated)
- **Roll20**: 30+ FPS (Browser-basiert, Canvas 2D)
- **Desktop Gaming Standards**: 60 FPS Minimum

**Messverfahren**:
- Chrome DevTools Performance Profiler
- FPS-Counter in PIXI.js Stats-Plugin
- Memory-Profiling via Chrome Task Manager
- Standardisierte Test-Szenarien (Kapitel 3.4)

**Code-Referenzen**:
- `src/app/pixi/grids/grid-renderer.ts:45` - Grid Performance Optimization
- `src/app/pixi/token-renderer/` - Token Performance (Culling, Batching)

---

### 2. Skalierbarkeit (0.2 Seiten)

**Anforderungen**:

| ID | Anforderung | Ziel | Begründung |
|----|-------------|------|------------|
| NF2.1 | Token Count | 100+ Tokens @ 30 FPS | Große Encounters (Battle Royale) |
| NF2.2 | Map Size | 8192×8192 px unterstützt | Hochauflösende Battle Maps |
| NF2.3 | Asset Library | 1000+ Tokens gecacht | Große Kampagnen |

**Technische Strategie**:
- Culling für Off-Screen-Objekte
- Texture Caching für wiederverwendete Assets
- Power-of-Two Textures für GPU-Optimierung

**Wissenschaftliche Grundlage**:
- PIXI.js Performance Guide: "Using 100s of graphics complex objects can be slow" ’ Object Pooling & Culling erforderlich

---

### 3. Plattform-Kompatibilität (0.2 Seiten)

**Obsidian/Electron Constraints**:

| ID | Constraint | Impact | Mitigation |
|----|-----------|--------|-----------|
| NF3.1 | Single-Bundle | Kein Code-Splitting | Tree-Shaking, Bundle Size Monitoring |
| NF3.2 | PIXI.js v7 Global Conflict | Namespace Collision | Explizite v8 Imports via npm |
| NF3.3 | File Access | Vault-relative Paths only | AssetManager mit Vault API |
| NF3.4 | No Tailwind (Limited) | Styling Constraints | SCSS + Obsidian Native Styles |

**Bundle Size**:
- **Ziel**: d3 MB für `main.js`
- **Aktuell**: ~2.5 MB (mit PIXI.js v8, React 19, Zustand)
- **Obsidian Guideline**: Empfohlenes Limit 244 KB (wird von großen Plugins überschritten)

**Platform-Spezifika**:
- Electron Environment (Node.js APIs verfügbar)
- Chromium-basiert (WebGL 2.0, Web Workers)
- Desktop-only (keine Mobile-Optimierung erforderlich)

---

### 4. Benutzerfreundlichkeit (0.2 Seiten)

**Anforderungen**:

| ID | Anforderung | Ziel | Begründung |
|----|-------------|------|------------|
| NF4.1 | Intuitive UI | GM kann ohne Tutorial starten | Niedrige Einstiegshürde |
| NF4.2 | Keyboard Shortcuts | Toolbar-Tools via Hotkeys | Power-User Efficiency |
| NF4.3 | Drag & Drop | Asset Browser ’ Map Placement | Standard VTT-Interaktion |
| NF4.4 | Undo/Redo | Ctrl+Z/Ctrl+Y für alle Actions | Error Recovery |

**Usability Standards**:
- **Jakob Nielsen**: Response Time <100ms für interaktive Systeme
- **Desktop Application Guidelines**: Keyboard-first Workflows

**Implementierung**:
- Zustand + Zundo für Undo/Redo
- React-DnD für Drag & Drop
- Toolbar mit Tool-Modus-Switching

---

### 5. Wartbarkeit und Code-Qualität (0.3 Seiten)

**Prinzipien**:

| ID | Prinzip | Umsetzung | Messbar |
|----|---------|-----------|---------|
| NF5.1 | Single Responsibility | Modulare Service-Architektur | LoC pro Modul <300 |
| NF5.2 | Type Safety | Strict TypeScript | 0 `any`-Types in Production Code |
| NF5.3 | Code Duplication | DRY-Prinzip | <5% Duplicate Code (SonarQube) |
| NF5.4 | Test Coverage | Unit & Integration Tests | >70% Coverage (Vitest) |

**Architektur-Pattern**:
- **Service-Oriented Architecture** - Modular, testbar
- **Event-Driven Communication** - Loose Coupling
- **Singleton State** - Zustand Store in `main.ts`

**Code-Qualität Metriken**:
- **Cyclomatic Complexity**: <10 pro Funktion
- **Function Length**: <50 LoC
- **File Length**: <300 LoC (Refactoring Threshold)

**Beispiel-Refactoring**:
- `TokenRenderer.ts`: 3,840 ’ 1,490 LoC (61% Reduktion)
- 15 Bugs während Refactoring gefunden
- Performance unverändert (validiert in Kap. 4)

---

### 6. Dokumentation (0.1 Seiten)

**Anforderungen**:

| ID | Anforderung | Format | Zweck |
|----|-------------|--------|-------|
| NF6.1 | Code-Dokumentation | TSDoc Comments | Onboarding neuer Entwickler |
| NF6.2 | Architecture Docs | Markdown in `docs/` | Design-Entscheidungen nachvollziehbar |
| NF6.3 | API Documentation | README.md | Plugin-Usage für Obsidian-User |

**Dokumentations-Standard**:
- TSDoc für alle Public APIs
- Architecture Decision Records (ADRs) für kritische Entscheidungen
- README mit Setup & Build Instructions

---

## =Ú Literatur und Quellen

### Externe Quellen (zu recherchieren)

#### Performance Standards
- [ ] **Jakob Nielsen** - Response Time Guidelines (100ms, 1s, 10s)
- [ ] **PIXI.js Performance Guide** - Best Practices für WebGL Rendering
- [ ] **Chrome DevTools Docs** - Performance Profiling Methodology
- [ ] **Electron Performance** - Memory Limits, Bundle Optimization

#### Software Engineering
- [ ] **Clean Code (Robert Martin)** - Code-Qualität Prinzipien
- [ ] **SonarQube Metrics** - Code Duplication, Complexity
- [ ] **TypeScript Best Practices** - Strict Mode, Type Safety

#### VTT Benchmarks
- [ ] **Foundry VTT Performance** - 60 FPS Standard
- [ ] **Roll20 Performance Comparison** - Canvas 2D vs WebGL

### Interne Quellen

- `tech_stack_and_dependencies.md` - Bundle Size, PIXI.js v8 Constraint
- `REFACTORING_PLAN.md` - Code-Qualität Verbesserungen (61% LoC-Reduktion)
- `grid-system-modernization-summary.md` - Performance-Optimierung (+40% FPS)
- `project_purpose_and_architecture.md` - Service-Oriented Architecture

---

## =¡ Schreibnotizen

### Stil
- Deutsch (außer Fachbegriffe)
- Tabellenformat für Anforderungen (NF1.X-Format)
- Quantifizierbare Ziele (Zahlen!)
- Verbindung zu Kapitel 4 (Messverfahren)

### Wissenschaftlich
- Performance-Ziele aus Industry Standards ableiten
- Messverfahren beschreiben (Chrome DevTools, FPS Counter)
- Plattform-Constraints als technische Limitierungen
- Code-Qualität Metriken aus Software Engineering Literature

### Zu vermeiden
- L Vage Aussagen ("sollte schnell sein")
- L Nicht-messbare Anforderungen
- L Subjektive Qualitätskriterien

### Zu betonen
-  Quantifizierbare Metriken (FPS, ms, MB, LoC)
-  Industry Benchmarks (Foundry VTT 60 FPS)
-  Obsidian/Electron Constraints (technisch begründet)
-  Verbindung zu Kapitel 4 (Wie wird gemessen?)

---

## = Verbindungen zu anderen Kapiteln

### Vorwärts-Verweise
- **3.3 Lösungsansätze** - Wie Performance-Anforderungen technisch erfüllt werden
- **3.4 Testumgebung** - Standardisierte Test-Szenarien
- **3.5 Messverfahren** - Wie FPS, Latency, Memory gemessen werden
- **4. Evaluation** - Validation der Performance-Ziele

### Rückwärts-Verweise
- **2.3.1 Performance-Metriken** - Theoretische Grundlagen
- **2.1.2 Electron Framework** - Platform Constraints
- **2.2.1 Virtual Tabletop Tools** - Industry Benchmarks

---

##  TODO beim Schreiben

### Research-Phase
- [ ] Jakob Nielsen Response Time Guidelines (exakte Zahlen)
- [ ] PIXI.js Performance Guide: FPS Benchmarks recherchieren
- [ ] Foundry VTT Performance-Daten (60 FPS Standard)
- [ ] Electron Bundle Size Best Practices
- [ ] SonarQube Code-Qualität Metriken

### Schreib-Phase
- [ ] Tabelle für Performance-Metriken (NF1.X)
- [ ] Plattform-Constraints beschreiben (PIXI v7/v8 Konflikt)
- [ ] Code-Qualität Beispiele (TokenRenderer Refactoring)
- [ ] Verweis auf Kapitel 4 (Messverfahren)
- [ ] BibTeX-Einträge parallel erstellen

### Review-Phase
- [ ] Alle Anforderungen quantifizierbar (Zahlen!)
- [ ] Messverfahren beschrieben
- [ ] Verbindung zu Kapitel 4 klar
- [ ] Industry Benchmarks zitiert

---

## <¯ Kernaussagen für LaTeX

### Zitierbare Statements

1. **Performance-Ziel**:
   > "Für flüssige Interaktionen in Desktop-Anwendungen wird ein Frame Rate von mindestens 30 FPS angestrebt, wobei 60 FPS den Industry Standard darstellen [Nielsen1993]."

2. **Obsidian Constraint**:
   > "Obsidian-Plugins müssen als Single-Bundle (eine `main.js` Datei) ausgeliefert werden, wodurch Code-Splitting unmöglich ist und die Bundle-Größe kritisch wird."

3. **PIXI.js Konflikt**:
   > "Obsidian bundelt PIXI.js v7 global, was zur Nutzung von PIXI.js v8 via explizite npm-Imports zwingt, um Namespace-Kollisionen zu vermeiden."

4. **Skalierbarkeits-Ziel**:
   > "Die Performance-Anforderungen definieren 100+ Tokens bei mindestens 30 FPS als Stress-Test-Szenario, basierend auf typischen D&D-Encounters."

5. **Code-Qualität**:
   > "Die Refactoring-Strategie reduzierte die Code-Komplexität von TokenRenderer um 61% (3,840 ’ 1,490 LoC) und identifizierte dabei 15 Bugs, ohne die Performance zu beeinträchtigen."

6. **Messbarkeit**:
   > "Alle Performance-Metriken werden mittels Chrome DevTools Performance Profiler und standardisierten Test-Szenarien quantifiziert, wodurch wissenschaftliche Reproduzierbarkeit gewährleistet ist."

---

**Letzte Aktualisierung**: 2025-01-24
**Nächster Schritt**: Research durchführen, dann LaTeX-Text schreiben
