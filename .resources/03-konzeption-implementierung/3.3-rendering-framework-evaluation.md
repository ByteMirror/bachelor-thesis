# 3.3 Evaluierung von Rendering-Frameworks für Virtual Tabletop
**Zweck**: Dokumentation der Framework-Entscheidung für Atlas VTT
**Erstellt**: 2025-01-21
**Status**: Research-Dokument für Thesis

---

## Kontext und Kernbotschaft

**Kernbotschaft**: Für ein performantes Virtual Tabletop Plugin in Obsidian war die Wahl des Rendering-Frameworks entscheidend. Die Anforderungen (viele Token, große Maps, 60 FPS) erforderten WebGL-Hardware-Beschleunigung, was die Entscheidung für PIXI.js v8 begründete.

**Forschungsfrage-Bezug**: "Wie beeinflussen Technologie-Entscheidungen die Performance eines VTT-Plugins?"

---

## Framework-Optionen für VTT-Entwicklung

### Option 1: Konva.js
**Technologie**: Canvas 2D API mit Hardware-Beschleunigung

#### Eigenschaften
- **Rendering**: HTML5 Canvas API (keine native WebGL-Unterstützung)
- **API-Level**: High-Level, deklarativ
- **Ease of Use**: ⭐⭐⭐⭐⭐ Sehr einfach
- **Performance**: ⭐⭐ Limitiert bei vielen Objekten

#### Performance-Daten (Benchmark: 8k Boxen auf MacBook Pro 2019)
| Browser | FPS |
|---------|-----|
| Chrome  | 23  |
| Firefox | 7   |
| Safari  | 19  |

**Quelle**: Canvas Engines Comparison (https://benchmarks.slaylines.io/konva.html)

#### Vor- und Nachteile

**Vorteile**:
- ✅ Einfache API, schnelle Prototyping
- ✅ Gute Dokumentation und Community
- ✅ Declarative API (React-Konva, Vue-Konva)
- ✅ Built-in Interaktivität (Drag & Drop, Events)

**Nachteile**:
- ❌ **Keine native WebGL-Unterstützung**
- ❌ Performance-Issues bei >100 Objekten
- ❌ Kein Hardware-beschleunigtes Rendering
- ❌ Limitiert auf Canvas 2D API

#### Geeignet für
- Diagramme und Data Visualization
- Einfache interaktive GUIs
- Prototyping
- **Nicht geeignet für**: Performance-kritische Anwendungen mit vielen Objekten

---

### Option 2: Fabric.js
**Technologie**: Canvas 2D API mit Fokus auf Objekt-Manipulation

#### Eigenschaften
- **Rendering**: HTML5 Canvas (pixel-basiert)
- **API-Level**: High-Level, objekt-orientiert
- **Ease of Use**: ⭐⭐⭐⭐ Einfach
- **Performance**: ⭐⭐ Ähnlich wie Konva

#### WebGL-Status (2024/2025)
> "At the time of writing, FabricJS WebGL renderer is still on the roadmap."

**Fabric.js hat KEINE native WebGL-Unterstützung** (Stand 2025)

#### Vor- und Nachteile

**Vorteile**:
- ✅ Sehr gute für Zeichnen und Objekt-Manipulation
- ✅ Einfache Transformationen (rotate, scale, skew)
- ✅ SVG Import/Export
- ✅ Gut dokumentiert

**Nachteile**:
- ❌ **Kein WebGL (noch in Roadmap)**
- ❌ Performance-Limitationen bei vielen Objekten
- ❌ Nicht optimiert für Spiele/Real-time Rendering

#### Geeignet für
- Grafik-Editoren (z.B. Canva)
- Bild-Manipulation
- Drawing Tools
- **Nicht geeignet für**: Performance-kritische Spiele oder VTTs

---

### Option 3: PIXI.js
**Technologie**: WebGL/WebGPU mit Canvas-Fallback

#### Eigenschaften
- **Rendering**: WebGL (primär), WebGPU (v8), Canvas 2D (Fallback)
- **API-Level**: Low-Level, performance-orientiert
- **Ease of Use**: ⭐⭐⭐ Moderate Learning Curve
- **Performance**: ⭐⭐⭐⭐⭐ Exzellent

#### Performance-Daten (Benchmark: 8k Boxen auf MacBook Pro 2019)
| Browser | FPS |
|---------|-----|
| Chrome  | **60**  |
| Firefox | **48**  |
| Safari  | 24  |

**→ 2-3x schneller als Konva.js**

**Quelle**: Canvas Engines Comparison (https://benchmarks.slaylines.io/)

#### Vor- und Nachteile

**Vorteile**:
- ✅ **Native WebGL-Hardware-Beschleunigung**
- ✅ Extrem hohe Performance (1000+ Sprites bei 60 FPS)
- ✅ GPU Memory Management
- ✅ Object Pooling
- ✅ Sprite Batching (reduziert Draw Calls)
- ✅ Texture Atlasing
- ✅ Culling (nicht-sichtbare Objekte werden nicht gerendert)
- ✅ WebGPU Support (v8)
- ✅ **Verwendet in Foundry VTT** (Industrie-Standard für VTT)

**Nachteile**:
- ❌ Steilere Lernkurve
- ❌ Low-Level API (mehr Code für einfache Dinge)
- ❌ WebGL/Shader-Kenntnisse hilfreich
- ❌ Kleinere Community als Canvas-Frameworks

#### Geeignet für
- **Games und interaktive Spiele**
- **Virtual Tabletops (Foundry VTT nutzt PIXI.js)**
- Real-time Rendering
- Performance-kritische Anwendungen
- Große Anzahl von Objekten (100+)

---

## Vergleich: Performance-Anforderungen VTT

### Typische VTT-Szenarien

| Szenario | Token-Anzahl | Map-Größe | Ziel-FPS |
|----------|--------------|-----------|----------|
| Leer     | 0            | -         | 60       |
| Standard | 8-15         | 2048x2048 | 60       |
| Stress   | 100+         | 4096x4096 | 30+      |

**Quelle**: Critical Role Campaign 3 Encounter Analysis (Median: 11 Entities)

### Framework-Performance bei VTT-Workloads

**Estimated Performance (basierend auf Benchmarks)**:

| Framework | 50 Token @ 2K Map | 100 Token @ 4K Map | Real-time Fog Updates |
|-----------|-------------------|--------------------|-----------------------|
| Konva.js  | ~20 FPS           | <10 FPS            | ❌ Laggy              |
| Fabric.js | ~25 FPS           | <15 FPS            | ❌ Laggy              |
| PIXI.js   | **60 FPS**        | **30-45 FPS**      | ✅ Smooth             |

**Schlussfolgerung**: Nur PIXI.js erfüllt Performance-Anforderungen für VTT.

---

## Entscheidungsmatrix

| Kriterium                  | Gewicht | Konva.js | Fabric.js | PIXI.js |
|----------------------------|---------|----------|-----------|---------|
| Performance (>30 FPS)      | 40%     | ❌ 2/10  | ❌ 2/10   | ✅ 10/10 |
| Hardware-Beschleunigung    | 30%     | ❌ 0/10  | ❌ 0/10   | ✅ 10/10 |
| Ease of Use                | 15%     | ✅ 9/10  | ✅ 9/10   | ⚠️ 6/10  |
| Community & Documentation  | 10%     | 8/10     | 7/10      | 8/10     |
| VTT Industry Usage         | 5%      | 0/10     | 0/10      | ✅ 10/10 |
| **Gesamt-Score**           | 100%    | **2.65** | **2.60**  | **9.05** |

**Entscheidung**: PIXI.js ist die einzige Option, die VTT-Performance-Anforderungen erfüllt.

---

## PIXI.js Version: v7 vs v8

### Foundry VTT's Entscheidung (2024)
Foundry VTT nutzt **PIXI v7** und plant KEINE Migration auf v8:

> "The team investigated shifting from PixiJS version 7 to version 8, but found the impacts would be far more sweeping and disruptive than planned for the developer community."

**Gründe gegen PIXI v8 (für Foundry VTT)**:
- ❌ WebGPU noch nicht production-ready
- ❌ Breaking Changes in API
- ❌ Event System wird nochmal überarbeitet
- ❌ Würde gesamten V13 Entwicklungszyklus konsumieren

**Quelle**: Foundry VTT GitHub Issue #11183

### Atlas VTT's Entscheidung: PIXI v8

**Warum Atlas VTT PIXI v8 wählt (trotz Foundry's Entscheidung gegen v8)?**

#### 1. Greenfield Projekt vs Legacy Codebase
- ✅ **Atlas VTT**: Neues Projekt, keine Legacy-Module
- ❌ **Foundry VTT**: Tausende Community-Module müssten migriert werden

#### 2. Obsidian's PIXI v7 Konflikt
**Kritisches Problem**: Obsidian bundelt bereits PIXI v7 global!

```typescript
// Problem: Obsidian hat window.PIXI (v7)
// → Konflikt wenn wir auch v7 nutzen würden

// Lösung: Eigenes PIXI v8 importieren
import { Application } from 'pixi.js'; // v8
// NICHT: window.PIXI verwenden
```

**Quelle**: `atlas-vtt/.serena/memories/tech_stack_and_dependencies.md`

#### 3. Moderne Features von PIXI v8
- ✅ Verbesserte TypeScript Support
- ✅ Modernere API (weniger Breaking Changes für neue Projekte)
- ✅ Bessere Performance durch optimierte Renderer
- ✅ WebGPU-Ready (für zukünftige Browser)

#### 4. Keine Breaking Changes für uns
- ✅ Keine existierenden Module zu migrieren
- ✅ Können von Anfang an v8 Best Practices nutzen
- ✅ Keine Community-Plugins die brechen würden

---

## Implementierung: PIXI.js v8 Best Practices

### 1. Texture Optimization (Grid System Beispiel)

**Problem**: Tausende von Grid-Linien → Hunderte Draw Calls

**Lösung**: TilingSprite mit Power-of-Two Textures

```typescript
// Statt: 1000 Linien einzeln zeichnen (1000 Draw Calls)
for (let i = 0; i < 1000; i++) {
  graphics.moveTo(i * gridSize, 0);
  graphics.lineTo(i * gridSize, height);
}

// Besser: TilingSprite (1 Draw Call!)
const gridTexture = generateGridPattern(gridSize);
const tilingSprite = new TilingSprite(gridTexture, width, height);
```

**Performance-Gewinn**:
- Draw Calls: 1000 → 1
- GPU Memory: 20 MB → 64 KB (Power-of-Two Texture)
- FPS: +40% bei großen Maps

**Quelle**: `atlas-vtt/grid-system-modernization-summary.md`

### 2. Object Pooling (Token Rendering)

```typescript
import { ObjectPool } from '@pixi-essentials/object-pool';

const spritePool = new ObjectPool({
  create: () => new Sprite(),
  reset: (sprite) => {
    sprite.texture = Texture.EMPTY;
    sprite.position.set(0, 0);
  }
});

// Reuse Sprites statt neue zu erstellen
const sprite = spritePool.allocate();
```

**Performance-Gewinn**: Reduziert GC Pressure, stabilere Frame-Times

### 3. Culling (Viewport Optimization)

```typescript
container.cullable = true;
container.cullArea = new Rectangle(0, 0, viewportWidth, viewportHeight);
```

**Performance-Gewinn**: Nur sichtbare Objekte werden gerendert

---

## Verbindung zu anderen Kapiteln

### → Kapitel 2.2.1 (Virtual Tabletop Tools)
- Foundry VTT als Industrie-Standard nutzt PIXI.js
- Roll20 nutzt Canvas 2D (ältere Technologie)

### → Kapitel 3.2.1 (Architekturentwurf)
- PIXI.js ermöglicht Layer-basierte Architektur
- Rendering Engine als Core Component

### → Kapitel 3.4/3.5 (Performance-Messungen)
- Framework-Wahl beeinflusst messbare Performance-Metriken
- WebGL-Beschleunigung als Baseline-Vorteil

### → Kapitel 4 (Evaluation)
- Vergleich mit Konva.js/Fabric.js als Baseline-Alternative
- Quantifizierung des Performance-Gewinns durch WebGL

---

## Literatur und Quellen

### Performance-Benchmarks
- **Canvas Engines Comparison**: https://benchmarks.slaylines.io/
  - Objektive Benchmarks: Konva vs PIXI vs andere
  - MacBook Pro 2019, 8k Boxen Test

- **Aircada Blog**: "PixiJS vs Konva: Which Holds the Aces?"
  - https://aircada.com/blog/pixijs-vs-konva

### Framework-Dokumentationen
- **PIXI.js Official Docs**: https://pixijs.com/8.x/guides/basics/what-pixijs-is
- **Konva.js Performance Test**: https://konvajs.org/docs/sandbox/Jumping_Bunnies.html
- **Stack Overflow Discussion**: "Pixi.js vs Konva.js vs D3.js"
  - https://stackoverflow.com/questions/57948360/pixi-js-vs-konva-js-vs-d3-js

### Foundry VTT (Industry Reference)
- **Foundry VTT Frameworks**: https://foundryvtt.com/article/frameworks/
- **GitHub Issue #11183**: "Adopt PIXI v8 as a comprehensive overhaul"
  - https://github.com/foundryvtt/foundryvtt/issues/11183
- **Foundry VTT PIXI Wiki**: https://foundryvtt.wiki/en/development/guides/pixi

### Atlas VTT Dokumentationen
- `tech_stack_and_dependencies.md` - PIXI v7 vs v8 Konflikt
- `grid-system-modernization-summary.md` - PIXI v8 Best Practices
- `REFACTORING_PLAN.md` - PIXI v8 Compatibility Issues

---

## Zitierbare Kernaussagen

> "In a performance comparison testing with 8k boxes on a MacBook Pro 2019, Pixi achieved 60 FPS in Chrome, while Konva achieved 23 FPS in Chrome"
> — Canvas Engines Comparison Benchmark

> "At the time of writing, FabricJS WebGL renderer is still on the roadmap."
> — Slant Comparison 2025

> "PixiJS is a powerful HTML5 WebGL library which powers FoundryVTT's canvas"
> — Foundry VTT Documentation

> "There are extensive API changes in the Pixi library [v8] that are not backwards compatible, which would cause breakage to almost all modules"
> — Foundry VTT GitHub Issue #11183

> "CRITICAL: Must use v8, NOT Obsidian's bundled v7"
> — Atlas VTT Tech Stack Documentation

---

## TODOs für Thesis-Schreibphase

- [ ] Performance-Benchmarks zitieren (mit Grafik)
- [ ] Foundry VTT als Industry Reference etablieren
- [ ] PIXI v7 vs v8 Entscheidung begründen (Obsidian-Konflikt!)
- [ ] Grid System als konkretes Code-Beispiel
- [ ] Entscheidungsmatrix als Tabelle in LaTeX
- [ ] WebGL vs Canvas 2D technisch erklären (kurz!)

---

**Letzte Aktualisierung**: 2025-01-21
**Version**: 1.0
**Autor**: Research für Fabian's Bachelorarbeit
