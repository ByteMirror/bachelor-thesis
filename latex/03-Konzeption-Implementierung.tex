\chapter{Konzeption und Implementierung}
\label{sec:KonzeptionImplementierung}

\section{Anforderungsanalyse}

Die Anforderungsanalyse bildet die Grundlage für die Konzeption und Implementierung von Atlas VTT. Die funktionalen und nicht-funktionalen Anforderungen werden aus bestehenden VTT-Standards, gängigen \ac{TTRPG} und der Obsidian-Plattform abgeleitet und nach Priorität kategorisiert.

\subsection{Funktionale Anforderungen}

VTTs digitalisieren klassisches Tabletop-RPG-Gameplay durch interaktive Karten, Token-basiertes Movement und Fog of War. Die funktionalen Anforderungen von Atlas VTT orientieren sich an etablierten VTT-Standards von Foundry VTT und Roll20 sowie an D\&D 5e Combat-Regeln. Im Gegensatz zu cloud-basierten Lösungen fokussiert Atlas VTT auf lokales Gameplay innerhalb Obsidian mit direkter Integration in das Vault-System.

\subsubsection{Karten-Management}

Das Karten-Management bildet die Basis jeder VTT-Session. Atlas VTT muss verschiedene Bildformate (JPEG, PNG, WebP) für Hintergrundkarten unterstützen und ein konfigurierbares Grid-Overlay bereitstellen. D\&D 5e definiert das Grid-basierte Movement-System mit einer Standardskalierung, bei der jedes Quadrat auf dem Grid 5 Fuß repräsentiert\autocite{DnDBasicRules2014}. Die Grid-Konfiguration muss verschiedene Größen, Offsets und Typen (Square, Hexagonal) unterstützen, da Battle Maps unterschiedliche Skalierungen aufweisen.

Die Persistenz erfolgt durch ein benutzerdefiniertes \texttt{.atlasmap}-Dateiformat, das Map-Konfiguration und platzierte Objekte als JSON speichert. Dies ermöglicht Session-Continuity und Integration in Obsidians Vault-Struktur. Multi-Scene-Support ermöglicht den Wechsel zwischen verschiedenen Locations innerhalb einer Kampagne.

Tabelle~\ref{tab:funktionale-anforderungen-karten} fasst die Karten-Management-Anforderungen zusammen:

\begin{table}[htbp]
	\centering
	\small
	\caption{Funktionale Anforderungen: Karten-Management}
	\label{tab:funktionale-anforderungen-karten}
	\begin{tabularx}{\textwidth}{llXl}
		\toprule
		\textbf{ID} & \textbf{Anforderung}                           & \textbf{Priorität} & \textbf{Standard} \\
		\midrule
		F1.1        & Laden von Hintergrundkarten (JPEG, PNG, WebP)  & P0                 & VTT-Standard      \\
		F1.2        & Grid-Overlay (Square, Hexagonal)               & P0                 & D\&D 5e           \\
		F1.3        & Grid-Konfiguration (Größe, Offset, Typ)        & P0                 & VTT-Standard      \\
		F1.4        & Speicherung als \texttt{.atlasmap} Dateiformat & P0                 & Persistenz        \\
		F1.5        & Multi-Scene-Support                            & P1                 & Nice-to-Have      \\
		\bottomrule
	\end{tabularx}
\end{table}

\subsubsection{Token-System}

Tokens repräsentieren Spielfiguren, NPCs und Monster auf der Map und sind die zentralen interaktiven Objekte in einem VTT\autocite{FoundryTokens2024}. Die grundlegenden Anforderungen umfassen Token Creation \& Placement, Drag \& Drop Movement mit Grid-Snapping und Token Rotation. D\&D 5e definiert für Movement-Berechnungen, dass eine typische mittelgroße Kreatur einen Raum von 5 Fuß Breite kontrolliert\autocite{DnDBasicRules2014}, was einer Token-Größe von 1×1 Grid-Squares entspricht.

Erweiterte Funktionen umfassen Multi-Selection für Gruppenbewegung, Health Bar Display für visuelles HP-Tracking und Status Icons für Conditions wie Prone oder Stunned. Die Token-Statblock Linking-Funktion ermöglicht bidirektionale Verlinkung zwischen Tokens und Markdown-basierten Character Sheets im Obsidian Vault, wodurch ein Click auf einen Token die zugehörigen Stats anzeigt. Diese Vault-native Integration unterscheidet Atlas VTT von cloud-basierten Lösungen.

\begin{table}[htbp]
	\centering
	\small
	\caption{Funktionale Anforderungen: Token-System}
	\label{tab:funktionale-anforderungen-token}
	\begin{tabularx}{\textwidth}{llXl}
		\toprule
		\textbf{ID} & \textbf{Anforderung}              & \textbf{Priorität} & \textbf{Standard}   \\
		\midrule
		F2.1        & Token Creation \& Placement       & P0                 & VTT-Standard        \\
		F2.2        & Drag \& Drop Movement             & P0                 & VTT-Standard        \\
		F2.3        & Grid-Snapping                     & P0                 & D\&D 5e             \\
		F2.4        & Token Rotation                    & P0                 & Combat Facing       \\
		F2.5        & Token Selection (Single \& Multi) & P0                 & VTT-Standard        \\
		F2.6        & Health Bar Display                & P1                 & Nice-to-Have        \\
		F2.7        & Status Icons                      & P1                 & Nice-to-Have        \\
		F2.8        & Token-Statblock Linking           & P1                 & Obsidian-spezifisch \\
		\bottomrule
	\end{tabularx}
\end{table}

\subsubsection{Fog of War}

Fog of War ermöglicht das Verbergen nicht-entdeckter Bereiche einer Map und ist ein Standard-Feature in VTTs wie Foundry VTT und Roll20\autocite{FoundryTokens2024}. Die Anforderungen umfassen das Erstellen von Fog Regions (Rectangle, Polygon), das progressive Aufdecken durch Fog Removal sowie separate Rendering-Modi: Der GM sieht die vollständige Map (GM-Only Preview) zur Fog-Planung, während die Player View Fog opaque rendert.

\begin{table}[htbp]
	\centering
	\small
	\caption{Funktionale Anforderungen: Fog of War}
	\label{tab:funktionale-anforderungen-fog}
	\begin{tabularx}{\textwidth}{llXl}
		\toprule
		\textbf{ID} & \textbf{Anforderung}                     & \textbf{Priorität} & \textbf{Standard} \\
		\midrule
		F3.1        & Fog Region Creation (Rectangle, Polygon) & P0                 & VTT-Standard      \\
		F3.2        & Fog Removal/Reveal                       & P0                 & VTT-Standard      \\
		F3.3        & GM-Only Preview (GM sieht full map)      & P0                 & VTT-Standard      \\
		F3.4        & Player View (Fog opaque)                 & P0                 & VTT-Standard      \\
		\bottomrule
	\end{tabularx}
\end{table}

\subsubsection{Werkzeuge und Interaktion}

Interaktive Werkzeuge unterstützen taktisches Gameplay und Map-Annotation. Das Measure Tool ermöglicht Distanzmessungen für D\&D 5e Movement und Spell Ranges. D\&D 5e definiert standardisierte Reichweiten für bestimmte Spielmechaniken die in einem Virtual-Tabletop System nachvollwerden werden müssen.\autocite{DnDBasicRules2014}. Note Pins verlinken Map-Positionen mit Obsidian Notes und integrieren VTT-Gameplay mit Vault Knowledge -- diese Obsidian-spezifische Integration unterscheidet Atlas VTT von anderen VTT-Lösungen. Drawing Tools und Text Placement ermöglichen zusätzliche Map-Annotationen.

\begin{table}[htbp]
	\centering
	\small
	\caption{Funktionale Anforderungen: Werkzeuge}
	\label{tab:funktionale-anforderungen-werkzeuge}
	\begin{tabularx}{\textwidth}{llXl}
		\toprule
		\textbf{ID} & \textbf{Anforderung}                & \textbf{Priorität} & \textbf{Standard}   \\
		\midrule
		F4.1        & Measure Tool (Distance Measurement) & P0                 & D\&D 5e             \\
		F4.2        & Drawing Tools (Freehand, Shapes)    & P1                 & Nice-to-Have        \\
		F4.3        & Note Pins (Link zu Obsidian Notes)  & P1                 & Obsidian-spezifisch \\
		F4.4        & Text Placement                      & P1                 & Nice-to-Have        \\
		\bottomrule
	\end{tabularx}
\end{table}

\subsubsection{Character Management}

Der Statblock Builder ermöglicht die Erstellung von D\&D 5e Character Sheets direkt in Obsidian. Statblocks werden als Markdown-Dateien mit YAML Frontmatter im Vault gespeichert, wodurch sie mit Obsidians Linking-System kompatibel sind. Die Token-Statblock Linking-Funktion ermöglicht bidirektionale Verlinkung zwischen Map-Tokens und Character Sheets. Diese Integration unterscheidet Atlas VTT von cloud-basierten VTTs, die separate Datenbanken verwenden.

\subsection{Nicht-funktionale Anforderungen}

Die nicht-funktionalen Anforderungen definieren messbare Qualitätsattribute für Performance, Skalierbarkeit, Plattform-Kompatibilität und Wartbarkeit. Diese Anforderungen sind quantifizierbar und basieren auf Industry Standards sowie Plattform-Constraints.

\subsubsection{Performance-Anforderungen}

Performance ist kritisch für flüssige Interaktionen in Desktop-Anwendungen. Nielsen beschreibt, dass Nutzer bei einer Reaktionszeit von 0.1 Sekunden (100ms) das System als augenblicklich reagierend wahrnehmen\autocite{Nielsen1993ResponseTimes}. Für Animationen und kontinuierliches Rendering gilt 60 FPS als Desktop-Standard, während 30 FPS als Minimum für flüssige Interaktionen definiert wird.

VTTs müssen große Maps und viele Tokens performant handhaben. Die PIXI.js-Dokumentation definiert einen performance-kritischen Schwellenwert, bei dem Hunderte komplexer Graphics-Objekte zu Performance-Problemen führen können\autocite{PixiPerf2024}, was typischen VTT-Szenarien mit 50-100+ Tokens bei großen Encounters entspricht. Die Memory-Anforderungen werden durch Electron-Limits auf maximal 500 MB für typische Szenarien begrenzt.

Tabelle~\ref{tab:nicht-funktionale-anforderungen-performance} definiert die quantifizierten Performance-Ziele:

\begin{table}[htbp]
	\centering
	\small
	\caption{Nicht-funktionale Anforderungen: Performance}
	\label{tab:nicht-funktionale-anforderungen-performance}
	\begin{tabularx}{\textwidth}{lXlXl}
		\toprule
		\textbf{ID} & \textbf{Metrik}     & \textbf{Ziel} & \textbf{Testszenario} & \textbf{Standard}                          \\
		\midrule
		NF1.1       & Frame Rate          & $\geq$30 FPS  & 50 Tokens, 2048px Map & Minimum                                    \\
		NF1.2       & Frame Rate (Ideal)  & $\geq$60 FPS  & Standard-Szenarien    & Desktop                                    \\
		NF1.3       & Interaction Latency & <100 ms       & Drag \& Drop Token    & Nielsen\autocite{Nielsen1993ResponseTimes} \\
		NF1.4       & Map Load Time       & <2 s          & 4096px Map            & UX                                         \\
		NF1.5       & Memory Footprint    & <500 MB       & 100 Tokens, 10 Maps   & Electron                                   \\
		\bottomrule
	\end{tabularx}
\end{table}

Die Messung erfolgt durch Chrome DevTools Performance Profiler und standardisierte Test-Szenarien, die in Kapitel~\ref{sec:evaluation} detailliert beschrieben werden. Dies ermöglicht wissenschaftliche Reproduzierbarkeit der Performance-Metriken.

\subsubsection{Skalierbarkeit}

Skalierbarkeits-Anforderungen definieren die Grenzen für Token Count, Map Size und Asset Library. Stress-Test-Szenarien mit 100+ Tokens bei mindestens 30 FPS simulieren große D\&D-Encounters. Maps bis 8192×8192 Pixel müssen unterstützt werden, um hochauflösende Battle Maps zu ermöglichen. Die Asset Library muss 1000+ gecachte Tokens für umfangreiche Kampagnen handhaben.

Die technische Strategie zur Erreichung dieser Skalierbarkeit basiert auf PIXI.js Performance Best Practices: Culling für Off-Screen-Objekte, Texture Caching für wiederverwendete Assets und Power-of-Two Textures für GPU-Optimierung\autocite{PixiPerf2024}. Die PIXI.js-Dokumentation warnt explizit, dass die Verwendung von Hunderten komplexen Graphics-Objekten langsam sein kann, was Object Pooling und Culling-Strategien erforderlich macht.

\subsubsection{Plattform-Kompatibilität}

Obsidian-Plugins unterliegen spezifischen Plattform-Constraints, die Architektur-Entscheidungen beeinflussen. Das Single-Bundle-Constraint erfordert, dass alle Plugin-Funktionalität in einer \texttt{main.js} Datei gebündelt wird, was Code-Splitting unmöglich macht und Tree-Shaking sowie Bundle Size Monitoring kritisch werden lässt\autocite{ObsidianPluginDev2024}. Das empfohlene Limit von 244 KB wird von großen Plugins regelmäßig überschritten; das Ziel für Atlas VTT liegt bei maximal 3 MB.

Ein kritischer Konflikt entsteht durch Obsidians globales PIXI.js v7 Bundle. Atlas VTT benötigt PIXI.js v8 für moderne Features, was explizite v8 Imports via npm erfordert, um Namespace-Kollisionen zu vermeiden. File Access ist auf Vault-relative Pfade beschränkt, weshalb der AssetManager ausschließlich Obsidians Vault API nutzt. Tailwind CSS ist nur eingeschränkt nutzbar, wodurch Styling primär durch SCSS und Obsidian Native Styles erfolgt.

\begin{table}[htbp]
	\centering
	\small
	\caption{Nicht-funktionale Anforderungen: Plattform-Constraints}
	\label{tab:nicht-funktionale-anforderungen-plattform}
	\begin{tabularx}{\textwidth}{lXXX}
		\toprule
		\textbf{ID} & \textbf{Constraint} & \textbf{Impact}      & \textbf{Mitigation}      \\
		\midrule
		NF3.1       & Single-Bundle       & Kein Code-Splitting  & Tree-Shaking, Monitoring \\
		NF3.2       & PIXI.js v7 Global   & Namespace Collision  & Explizite v8 Imports     \\
		NF3.3       & File Access         & Vault-relative Paths & AssetManager + Vault API \\
		NF3.4       & Tailwind Limited    & Styling Constraints  & SCSS + Native Styles     \\
		\bottomrule
	\end{tabularx}
\end{table}

\subsubsection{Wartbarkeit und Code-Qualität}

Wartbarkeit wird durch etablierte Software Engineering Prinzipien sichergestellt. Das Single Responsibility Principle wird durch modulare Service-Architektur umgesetzt, wobei jedes Modul maximal 300 Lines of Code umfassen sollte\autocite{MartinCleanCode2008}. Strict TypeScript mit vollständiger Type Safety eliminiert \texttt{any}-Types in Production Code. Das DRY-Prinzip begrenzt Code Duplication auf unter 5\%.

Die Architektur folgt Service-Oriented Architecture mit Event-Driven Communication für Loose Coupling und Singleton State durch Zustand Store in \texttt{main.ts:atlasStore}. Code-Qualität Metriken umfassen Cyclomatic Complexity unter 10 pro Funktion, Function Length unter 50 Lines of Code und File Length unter 300 Lines of Code als Refactoring Threshold. Diese Metriken werden kontinuierlich überwacht, um Code-Wartbarkeit über den gesamten Entwicklungszyklus sicherzustellen.

\subsubsection{Benutzerfreundlichkeit}

Usability-Anforderungen fokussieren auf intuitive UI, Keyboard Shortcuts für Power-User, Drag \& Drop für Standard-VTT-Interaktionen und Undo/Redo (Ctrl+Z/Ctrl+Y) für Error Recovery. Die Implementierung nutzt Zustand mit Zundo für Undo/Redo-Funktionalität, React-DnD für Drag \& Drop und eine Toolbar mit Tool-Modus-Switching. Das Ziel ist, dass Game Masters ohne Tutorial mit dem System arbeiten können, was niedrige Einstiegshürden voraussetzt.

\section{Systemdesign}

\subsection{Architekturentwurf}

Die Architektur von Atlas VTT wurde als modulare, service-orientierte Architektur konzipiert, um die spezifischen Herausforderungen eines VTT-Plugins in der Obsidian-Umgebung zu adressieren. Die folgenden Abschnitte beschreiben die architektonischen Entscheidungen und deren Begründung.

\subsubsection{Design-Prinzipien und Architektur-Überblick}

Die Architektur folgt vier zentralen Design-Prinzipien, die aus etablierten Software Engineering Patterns abgeleitet wurden:

\textbf{Service-orientierte Architektur (SOA)} organisiert Funktionalität in über 50 eigenständige Services, die jeweils eine klar definierte Verantwortlichkeit besitzen. Fowler beschreibt Service-Orientierung als Organisation von Services um Geschäftsfähigkeiten herum\autocite{Fowler2014}. Für Atlas VTT bedeutet dies die Aufteilung in Services wie \texttt{AssetService}, \texttt{NetworkService}, \texttt{AudioService} und \texttt{TokenStatblockLinkService}, die unabhängig entwickelt, getestet und gewartet werden können.

\textbf{Single Responsibility Principle (SRP)} stellt sicher, dass jedes Modul nur eine Änderungsursache hat. Martin definiert das Prinzip dahingehend, dass eine Klasse nur einen Grund haben sollte, sich zu ändern\autocite{Martin2017}. Dies reduziert die Kopplung zwischen Komponenten und erhöht die Kohäsion innerhalb einzelner Module, was insbesondere bei komplexen VTT-Features wie Token-Rendering oder Fog of War-Berechnung die Wartbarkeit verbessert.

\textbf{Event-Driven Communication} entkoppelt Services durch asynchrone Event-Emission statt direkter Methodenaufrufe. Dieses Pattern entspricht dem Observer Pattern aus Gamma et al.\autocite{Gamma1994}, bei dem Subjekte Zustandsänderungen an interessierte Observer kommunizieren, ohne deren konkrete Implementierung zu kennen. In Atlas VTT kommunizieren Services über Events wie \texttt{atlas-vtt:refresh-assets} oder \texttt{link-changed}, wodurch neue Features hinzugefügt werden können, ohne bestehende Services zu modifizieren.

\textbf{Singleton Pattern für zentrale Services} wird für Services eingesetzt, die vault-weiten Zustand verwalten müssen. Gamma et al. definieren das Singleton Pattern als Entwurfsmuster, bei dem eine Klasse nur eine Instanz hat und einen globalen Zugriffspunkt darauf bietet\autocite{Gamma1994}. Dies ist kritisch für den \texttt{AssetService}, da Asset-Metadaten über alle geöffneten Map-Views hinweg konsistent sein müssen, um Dateninkonsistenzen zu vermeiden.

Der Trade-off dieser Architektur liegt in erhöhter Code-Komplexität: Service-orientierte Systeme benötigen mehr Boilerplate-Code für Service-Registration, Event-Handling und Dependency Injection im Vergleich zu monolithischen Architekturen. Fowler warnt, dass Microservices einen Preis in Form von operationaler Komplexität haben\autocite{Fowler2014}. Für Atlas VTT wurde dieser Trade-off als akzeptabel bewertet, da die Vorteile in Wartbarkeit und Testbarkeit die zusätzliche Komplexität überwiegen, insbesondere bei einem Plugin mit über 30.000 Zeilen Code.

\subsubsection{Layer-Architektur}

Die Implementierung folgt einer Layered Architecture. Buschmann et al. beschreiben dieses Pattern als Zerlegung des Systems in Schichten, wobei jede Schicht Services für die darüberliegende Schicht bereitstellt\autocite{Buschmann1996}. Atlas VTT implementiert vier Haupt-Layer:

\paragraph{View Layer}

Der View Layer umfasst alle Benutzeroberflächen-Komponenten und ist für die Darstellung und Nutzerinteraktion verantwortlich. Die Hauptkomponenten sind:

\begin{itemize}
	\item \texttt{atlas-view.ts} -- GM/Host View für Spielleiter mit vollem Zugriff auf alle Map-Objekte
	\item \texttt{player-view.ts} -- Dediziertes Player Window ohne GM-only Elemente
	\item \texttt{dashboard-view.tsx} -- Zentraler Hub für Session-Management
	\item \texttt{statblock-view.tsx} -- Character Sheet Builder mit D\&D 5e Layouts
\end{itemize}

Alle Views sind als React 19 Komponenten implementiert, was deklarative UI-Entwicklung und effizientes Re-Rendering durch Virtual DOM ermöglicht. Die Wahl von React folgt dem Industry Standard für moderne Web-UIs und ermöglicht Wiederverwendung von UI-Komponenten aus dem Radix UI Ecosystem.

\paragraph{Rendering Layer}

Der Rendering Layer ist verantwortlich für die performante Darstellung der Map, Tokens und Effekte auf einem HTML5 Canvas. Die Kernkomponenten sind:

\begin{itemize}
	\item \texttt{PixiRendererOrchestrator.ts} -- Zentrale Orchestrierung des Rendering-Prozesses
	\item \texttt{LayerManager.ts} -- Verwaltung von Rendering-Layern (Background, Grid, Tokens, Fog, UI)
	\item \texttt{pixi-viewport} -- Kamera-Kontrolle mit Pan, Zoom und Boundary-Handling
	\item Token-/Grid-/Fog-Renderer -- Spezialisierte Renderer für verschiedene Map-Objekte
\end{itemize}

Die kritische Design-Entscheidung war die strikte Separation zwischen React (UI Layer) und PIXI.js (Rendering Layer). React-Komponenten modifizieren niemals direkt PIXI.js Display Objects; stattdessen aktualisieren sie den zentralen State, woraufhin Renderer den neuen State reflektieren. Diese unidirektionale Datenfluss-Architektur entspricht dem Flux-Pattern und verhindert Race Conditions zwischen UI-Updates und Canvas-Rendering.

\paragraph{State Management Layer}

Der State Management Layer implementiert eine centralized state architecture mit Zustand als State Management Library. Die Hauptkomponenten sind:

\begin{itemize}
	\item \texttt{atlasStore.ts} -- Globaler Application State (Map-Daten, UI-Zustand, Tool-Modus)
	\item \texttt{storeFactory.ts} -- Factory für View-spezifische Store-Instanzen
	\item \texttt{tabStore.ts} -- Tab-spezifischer State für Multi-Map-Support
	\item \texttt{zundo} -- Middleware für Undo/Redo-Funktionalität
	\item \texttt{immer} -- Middleware für immutable State-Updates
\end{itemize}

Die Verwendung von Immer garantiert Immutability durch strukturelles Sharing: State-Updates erzeugen neue Objekte statt bestehende zu mutieren, was Time-Travel Debugging und Undo/Redo ohne zusätzliche Logik ermöglicht. Der Performance-Overhead durch Object-Copies wird durch Immer's Copy-on-Write Algorithmus minimiert, der nur geänderte Teile des State-Trees kopiert\autocite{ImmerDocs2024}.

\paragraph{Service Layer}

Der Service Layer enthält über 50 spezialisierte Services, die Geschäftslogik, externe API-Calls und Daten-Persistierung kapseln. Wichtige Services sind:

\begin{itemize}
	\item \texttt{AssetService} (Singleton) -- Vault-wide Asset-Metadaten-Verwaltung
	\item \texttt{TokenStatblockLinkService} (Singleton) -- Bidirektionale Token-Statblock-Verlinkung
	\item \texttt{NetworkService} -- WebSocket-basiertes Multiplayer über PartyKit
	\item \texttt{AudioService} -- Sound Effect Playback via Howler.js
	\item \texttt{MapService} -- Map Loading/Saving/Validation
	\item \texttt{CharacterService} -- Character Data Management
\end{itemize}

Die Entscheidung für das Singleton Pattern bei \texttt{AssetService} wurde durch eine zentrale Anforderung motiviert: Asset-Metadaten sind vault-weit, d.h. die Verlinkung eines Tokens zu einem Statblock muss über alle Maps hinweg konsistent sein. Multiple \texttt{AssetService}-Instanzen würden zu inkonsistenten Metadaten-Zuständen führen, wenn zwei Maps gleichzeitig dieselben Assets verwenden. Das Singleton Pattern eliminiert diese Race Condition, indem es einen globalen, synchronisierten Zugriffspunkt garantiert.

\subsubsection{Integration mit Obsidian Plugin API}

Die Integration mit der Obsidian Plugin API stellt spezifische Herausforderungen, da Atlas VTT sowohl native Obsidian-Funktionalität (Vault-Access, Metadata-Cache, Events) als auch externe Frameworks (React, PIXI.js) kombinieren muss.

\paragraph{Plugin Lifecycle Management}

Atlas VTT integriert sich über die Standard Plugin Lifecycle Hooks:

\begin{lstlisting}[float,language=TypeScript,caption={Plugin Lifecycle Integration},label=lst:plugin-lifecycle]
// main.ts:45-67
export default class AtlasVTTPlugin extends Plugin {
  async onload() {
    // 1. Register Custom View Types
    this.registerView("atlas-vtt", (leaf) => new AtlasView(leaf, this));

    // 2. Initialize Singleton Services
    this.assetService = AssetService.getInstance(this.app);
    this.linkService = new TokenStatblockLinkService(this.app);

    // 3. Register Commands & Ribbon Icons
    this.addRibbonIcon("map", "Open Atlas VTT", () => {
      this.activateView();
    });

    // 4. Register Event Handlers
    this.registerEvent(
      this.app.workspace.on("atlas-vtt:refresh-assets", () => {
        this.assetService.refreshMetadata();
      })
    );
  }

  async onunload() {
    // Cleanup: Detach views, close connections
    this.app.workspace.detachLeavesOfType("atlas-vtt");
  }
}
\end{lstlisting}

\paragraph{DeferredView Handling}

Eine kritische Obsidian-spezifische Constraint ist das DeferredView-System: Obsidian lädt Views lazy, um Startup-Performance zu optimieren. Direkter Zugriff auf eine nicht-geladene View führt zu \texttt{undefined}-Fehlern. Die Lösung besteht in explizitem Laden vor Zugriff:

\begin{lstlisting}[language=TypeScript,caption={DeferredView Safety Pattern},label=lst:deferred-view]
// Falsch: Direkter Zugriff kann fehlschlagen
const view = this.app.workspace.getLeavesOfType("atlas-vtt")[0].view;

// Korrekt: Explizites Laden vor Zugriff
const leaf = this.app.workspace.getLeavesOfType("atlas-vtt")[0];
await leaf.loadIfDeferred();
const view = leaf.view as AtlasView;
\end{lstlisting}

Diese Constraint stellt ein dokumentiertes Risiko dar und erfordert explizites Laden via \texttt{await leaf.loadIfDeferred()} vor jedem View-Zugriff.

\paragraph{PIXI.js Version Konflikt}

Die technisch komplexeste Integration-Herausforderung entsteht durch Obsidians globales PIXI.js v7 Bundle. Obsidian stellt PIXI.js v7 als \texttt{window.PIXI} bereit, jedoch benötigt Atlas VTT PIXI.js v8 für moderne Features wie verbesserten Batch Renderer und WebGPU-Vorbereitung. Die Verwendung beider Versionen gleichzeitig würde zu Type-Konflikten und Runtime-Fehlern führen.

Die Lösung besteht darin, PIXI.js v8 als explizite npm-Dependency zu deklarieren und ausschließlich über ES6-Imports zu verwenden:

\begin{lstlisting}[language=TypeScript,caption={PIXI.js v8 Import Pattern},label=lst:pixi-import]
// Falsch: Verwendet Obsidians PIXI v7
const app = new PIXI.Application();

// Korrekt: Expliziter Import von PIXI v8
import { Application, Sprite, Container } from 'pixi.js';
const app = new Application();
\end{lstlisting}

Diese Entscheidung unterscheidet sich von Foundry VTT, das bei PIXI.js v7 verbleibt. Das Foundry-Entwicklerteam begründet dies damit, dass eine Migration Breaking Changes für das Modul-Ökosystem bedeuten würde\autocite{FoundryIssue11183}. Für Atlas VTT als Greenfield-Projekt entstehen keine Legacy-Migrationskosten, während v8-Features wie das vereinfachte Package-System, asynchrone Initialisierung für WebGPU-Support und optimierte Culling-Controls genutzt werden können\autocite{PixiV8Migration2024}.

Der Trade-off dieser Lösung ist erhöhter Bundle-Size: PIXI.js v8 fügt ~500 KB zum finalen Bundle hinzu. Dieser Overhead wird bewusst in Kauf genommen, da die konsolidierte Package-Struktur von v8 Version-Konflikte eliminiert und die modernen API-Patterns die Wartbarkeit erhöhen\autocite{PixiV8Migration2024}.

\subsection{Datenmodell}

Das Datenmodell von Atlas VTT wurde konzipiert, um VTT-spezifische Anforderungen wie Multi-Scene-Support, Undo/Redo und vault-wide Asset-Konsistenz zu erfüllen. Die folgenden Abschnitte beschreiben die Datenstrukturen und deren Persistierungsstrategien mit wissenschaftlicher Begründung der Design-Entscheidungen.

\subsubsection{Datenmodell-Architektur}

Das Datenmodell ist in drei separate Bereiche unterteilt, die jeweils unterschiedliche Persistierungs- und Konsistenz-Anforderungen haben:

\textbf{Map Data} (persistent, pro-Map) speichert Map-spezifische Informationen wie Background-Image, Grid-Konfiguration und platzierte Objekte im \texttt{.atlasmap} JSON-Format. Jede Map ist eine eigenständige Datei im Obsidian Vault, was git-basierte Versionskontrolle und Kollaboration ermöglicht.

\textbf{Asset Metadata} (persistent, vault-wide) verwaltet wiederverwendbare Assets wie Token-Images, Sound Effects und Map-Templates in einer zentralen \texttt{assets-metadata.json} Datei. Diese Separation verhindert Daten-Duplikation: Ein Token-Image kann in mehreren Maps verwendet werden, ohne dass dessen Metadaten (Tags, Statblock-Link) redundant gespeichert werden müssen.

\textbf{Application State} (transient, pro-View) hält Runtime-Zustand wie aktuelle Tool-Auswahl, Viewport-Position und UI-Zustand. Dieser State ist nicht persistent und wird bei jedem Plugin-Start neu initialisiert, was Startup-Geschwindigkeit und Memory-Effizienz optimiert.

Diese Separation entspricht dem Data Access Object (DAO) Pattern von Fowler\autocite{Fowler2003}, bei dem Daten-Zugriff von Geschäftslogik getrennt wird. Für Atlas VTT bedeutet dies, dass Services ausschließlich über definierte Schnittstellen (\texttt{MapService}, \texttt{AssetService}) auf persistente Daten zugreifen, nicht direkt auf Dateien.

\subsubsection{Map Data Format}

Das \texttt{.atlasmap}-Format speichert Map-Konfiguration und platzierte Objekte als JSON:

\begin{lstlisting}[language={},caption={.atlasmap JSON Schema},label=lst:atlasmap-schema]
{
  "version": 1,
  "name": "Dungeon Level 1",
  "background": {
    "image": "atlas-vtt/maps/dungeon1.jpg",
    "grid": {
      "type": "square",
      "size": 70,
      "distance": 5,
      "units": "ft"
    }
  },
  "objects": [
    {
      "type": "Token",
      "id": "uuid-abc-123",
      "x": 350,
      "y": 280,
      "image": "atlas-vtt/tokens/goblin.png",
      "rotation": 0,
      "size": 1,
      "statblockPath": "statblocks/Goblin.md"
    },
    {
      "type": "FogRegion",
      "id": "uuid-def-456",
      "shape": "rect",
      "x": 100,
      "y": 100,
      "width": 200,
      "height": 150
    }
  ]
}
\end{lstlisting}

Die Wahl von JSON als Datenformat wurde durch mehrere Faktoren motiviert: JSON ist human-readable und damit git-friendly, was Diff-Visualisierung und Merge-Konflikt-Auflösung bei kollaborativer Map-Entwicklung erleichtert\autocite{JSON2017}. Binäre Formate wie Protocol Buffers wären kompakter (~30\% kleinere Files), jedoch auf Kosten der Lesbarkeit und Git-Integration. Da Obsidian-Vaults typischerweise auf lokalen SSDs liegen und nicht über Netzwerk geladen werden, ist File-Size weniger kritisch als bei cloud-basierten VTTs.

Die \texttt{objects}-Array enthält polymorphe Objekte verschiedener Typen (Token, FogRegion, NotePin), die durch ein \texttt{type}-Diskriminator-Feld unterschieden werden. Dieses Pattern entspricht dem Subtype Polymorphism Pattern und ermöglicht Erweiterbarkeit: Neue Objekt-Typen können hinzugefügt werden, ohne bestehende Maps zu invalidieren, solange das \texttt{version}-Feld entsprechend inkrementiert wird.

\paragraph{MapObject-Hierarchie}

Die TypeScript-Implementierung nutzt eine abstrakte Basisklasse für gemeinsame Eigenschaften:

\begin{lstlisting}[language=TypeScript,caption={MapObject Class Hierarchy},label=lst:mapobject-hierarchy]
// src/app/types.ts:89-125
abstract class MapObject {
  id: string;
  x: number;
  y: number;
  gmOnly?: boolean;
  draggable: boolean = true;

  abstract serialize(): object;
}

class Token extends MapObject {
  image: string;
  rotation: number = 0;
  size: number = 1;
  statblockPath?: string;

  serialize(): object {
    return { type: "Token", ...this };
  }
}

class FogRegion extends MapObject {
  shape: "rect" | "poly";
  points: number[];

  serialize(): object {
    return { type: "FogRegion", ...this };
  }
}
\end{lstlisting}

Diese Hierarchie folgt dem Open/Closed Principle: Das System ist offen für Erweiterung (neue Objekt-Typen) aber geschlossen für Modifikation (bestehende Typen bleiben unverändert)\autocite{Martin2017}. Der Trade-off liegt in erhöhter Type-Komplexität: TypeScript's Type System benötigt Type Guards für Discriminated Unions, um Type-Safety zur Compile-Zeit zu garantieren.

\subsubsection{Asset Metadata System}

Asset-Metadaten werden vault-wide in \texttt{assets-metadata.json} gespeichert, um Konsistenz über alle Maps hinweg zu garantieren:

\begin{lstlisting}[language={},caption={Asset Metadata Schema},label=lst:asset-metadata]
{
  "tokens": [
    {
      "id": "uuid-token-001",
      "name": "Goblin",
      "imagePath": "atlas-vtt/tokens/goblin.png",
      "statblockPath": "statblocks/Goblin.md",
      "tags": ["monster", "small", "goblinoid"],
      "createdAt": 1704067200000,
      "modifiedAt": 1704153600000
    }
  ],
  "maps": [ /* ... */ ],
  "sounds": [ /* ... */ ]
}
\end{lstlisting}

Die Entscheidung für eine zentrale Metadata-Datei statt verteilter Metadaten (z.B. Sidecar-Files pro Asset) wurde durch eine zentrale Anforderung motiviert: Asset-Metadaten müssen vault-weit konsistent sein, sodass die Verlinkung eines Tokens zu einem Statblock über alle Maps hinweg identisch bleibt. Eine dezentrale Lösung würde bei Änderungen (z.B. Statblock-Link-Update) alle Maps durchsuchen und aktualisieren müssen, was bei großen Vaults mit vielen Maps zu erheblichen Performance-Problemen führen würde, da jede Änderung alle Map-Dateien lesen und schreiben müsste. Die zentrale Lösung ermöglicht direkten Zugriff auf Metadaten über \texttt{AssetService} als Singleton, ohne dass Maps durchsucht werden müssen.

Der Trade-off ist Skalierbarkeit: Bei sehr großen Vaults (>10.000 Assets) kann das Laden der gesamten Metadata-Datei Memory-intensiv werden. Für typische VTT-Vaults mit 100-500 Assets ist dieser Overhead vernachlässigbar (~50-250 KB JSON).

\paragraph{Singleton AssetService}

Der \texttt{AssetService} implementiert das Singleton Pattern\autocite{Gamma1994}, um Metadata-Konsistenz bei mehreren gleichzeitig geöffneten Maps zu garantieren:

\begin{lstlisting}[language=TypeScript,caption={AssetService Singleton Implementation},label=lst:asset-service-singleton]
// src/app/services/AssetService.ts:23-45
export class AssetService {
  private static instance: AssetService | null = null;
  private metadata: AssetMetadata | null = null;

  private constructor(private app: App) {}

  public static getInstance(app: App): AssetService {
    if (!AssetService.instance) {
      AssetService.instance = new AssetService(app);
    }
    return AssetService.instance;
  }

  async getAssets(): Promise<Asset[]> {
    if (!this.metadata) {
      await this.loadMetadata();
    }
    return this.metadata.tokens.concat(
      this.metadata.maps,
      this.metadata.sounds
    );
  }
}
\end{lstlisting}

Diese Implementierung garantiert, dass alle Map-Views denselben \texttt{AssetService} verwenden und somit konsistente Metadaten sehen. Ohne Singleton würde View A Asset-Metadaten ändern, während View B veraltete Daten hat, was zu Race Conditions beim gleichzeitigen Token-Spawning führen würde.

\subsubsection{Statblock Data}

Character- und Monster-Daten werden als YAML Frontmatter in Markdown-Dateien gespeichert, um native Obsidian-Integration zu nutzen:

\begin{lstlisting}[float,language={},caption={Statblock YAML Frontmatter},label=lst:statblock-frontmatter]
---
name: "Goblin"
token-image: "atlas-vtt/tokens/goblin.png"
hp: 7
ac: 15
speed: 30
abilities:
  str: 8
  dex: 14
  con: 10
  int: 10
  wis: 8
  cha: 8
traits:
  - name: "Nimble Escape"
    description: "Can Disengage or Hide as bonus action"
actions:
  - name: "Scimitar"
    description: "+4 to hit, 1d6+2 slashing damage"
---

# Goblin

Additional GM notes...
\end{lstlisting}

Die Verwendung von YAML Frontmatter folgt Obsidian's native Metadata-System und ermöglicht Statblock-Queries über Obsidian's Dataview Plugin. Der Trade-off ist erhöhte Parsing-Komplexität: Atlas VTT muss YAML parsen und validieren, während ein custom JSON-Format einfacher zu verarbeiten wäre. Der Vorteil liegt in Interoperabilität: Statblocks bleiben als normale Markdown-Notes editierbar, auch ohne Atlas VTT.

\paragraph{Bidirektionale Token-Statblock-Verlinkung}

Das System erzwingt One-to-One Relationships zwischen Tokens und Statblocks: Ein Token kann maximal einen Statblock referenzieren, und ein Statblock kann maximal einen Token haben. Dies wird durch den \texttt{TokenStatblockLinkService} (Singleton) garantiert:

\begin{lstlisting}[language=TypeScript,caption={Bidirectional Linking Logic},label=lst:bidirectional-linking]
// src/app/services/TokenStatblockLinkService.ts:67-95
async linkTokenToStatblock(
  tokenImagePath: string,
  statblockPath: string
): Promise<boolean> {
  // 1. Check if statblock already has a token -> unlink old token
  const existingToken = await this.getTokenLinkedToStatblock(statblockPath);
  if (existingToken) {
    await this.unlinkToken(existingToken);
  }

  // 2. Update AssetService metadata
  await this.assetService.updateAsset(tokenImagePath, {
    statblockPath: statblockPath
  });

  // 3. Update statblock frontmatter
  await this.updateStatblockFrontmatter(statblockPath, {
    "token-image": tokenImagePath
  });

  // 4. Emit events for synchronization
  this.emit("link-changed", { tokenImagePath, statblockPath });
  this.app.workspace.trigger("atlas-vtt:refresh-assets");

  return true;
}
\end{lstlisting}

Diese bidirektionale Synchronisation entspricht dem Two-Way Data Binding Pattern und stellt Data Integrity durch Konsistenz-Checks sicher. Der Performance-Overhead ist minimal, da nur die betroffene Metadata-Datei und das spezifische YAML-Frontmatter aktualisiert werden müssen, ohne dass andere Dateien durchsucht werden.

\subsubsection{Application State Management}

Der Runtime-Zustand wird mit Zustand\autocite{ZustandDocs2024} als State Management Library verwaltet:

\begin{lstlisting}[language=TypeScript,caption={Atlas Store Structure},label=lst:atlas-store]
// src/app/atlasStore.ts:34-67
interface AtlasState {
  // Map State
  currentMap: MapData | null;
  mapObjects: MapObject[];
  selectedObjects: string[];

  // Tool State
  activeTool: ToolType;

  // UI State
  sidebarOpen: boolean;
  assetBrowserTab: string;

  // Player Mode
  isPlayerMode: boolean;

  // Viewport State
  zoom: number;
  pan: { x: number; y: number };

  // Actions
  addObject: (obj: MapObject) => void;
  removeObject: (id: string) => void;
  updateObject: (id: string, updates: Partial<MapObject>) => void;
  setActiveTool: (tool: ToolType) => void;
}

export const useAtlasStore = create<AtlasState>()(
  temporal( // zundo middleware for undo/redo
    immer((set) => ({ // immer middleware for immutability
      currentMap: null,
      mapObjects: [],
      // ... initial state
      addObject: (obj) => set((state) => {
        state.mapObjects.push(obj);
      }),
    }))
  )
);
\end{lstlisting}

Die Verwendung von Immer garantiert Immutability durch Copy-on-Write: State-Updates erzeugen neue Objekte statt Mutations, was Time-Travel Debugging und Undo/Redo ohne zusätzliche Logik ermöglicht\autocite{ImmerDocs2024}. Die Zundo-Middleware fügt automatisch Undo/Redo-History hinzu, mit konfigurierbarem Limit (Standard: 50 Steps).

Der Trade-off ist Memory-Overhead: Immutable Updates kopieren Objektteile, was bei großen State-Trees (z.B. 100+ MapObjects) zu erhöhtem Memory-Verbrauch führt. Immer minimiert dies durch strukturelles Sharing, das nur geänderte Pfade kopiert, nicht den gesamten Tree.

\subsubsection{Datenpersistenz und Synchronisation}

Die Persistierung von Map-Änderungen nutzt Debouncing zur I/O-Reduktion:

\begin{lstlisting}[language=TypeScript,caption={Autosave with Debouncing},label=lst:autosave-debouncing]
// src/app/MapController.ts:234-256
private setupAutosave() {
  let timeout: NodeJS.Timeout;

  this.store.subscribe((state) => {
    clearTimeout(timeout);
    timeout = setTimeout(async () => {
      await this.saveMap(state.currentMap);
    }, 1000); // 1 second debounce
  });
}

private async saveMap(mapData: MapData) {
  const json = JSON.stringify(mapData, null, 2);
  await this.app.vault.modify(this.mapFile, json);
}
\end{lstlisting}

Das 1-Sekunden Debounce-Intervall wurde empirisch gewählt: Es ist kurz genug, um gefühlte Instant-Saves zu ermöglichen, aber lang genug, um bei Drag \& Drop-Operationen (typischerweise 60 Updates/Sekunde) I/O-Operations um ~98\% zu reduzieren (60 Updates/s → 1 Save/s). Ohne Debouncing würde jedes Token-Movement einen Disk-Write triggern, was bei mechanischen HDDs zu Performance-Einbußen führen würde.

\paragraph{Event-Driven Multi-View Synchronisation}

Bei mehreren gleichzeitig geöffneten Maps kommunizieren Views über Obsidian's Workspace Events:

\begin{lstlisting}[language=TypeScript,caption={Event-Driven Asset Refresh},label=lst:event-driven-refresh]
// src/app/services/TokenStatblockLinkService.ts:178-195
async linkTokenToStatblock(...) {
  // ... perform linking logic

  // Emit custom event for Service-to-Service communication
  this.emit("link-changed", { tokenImagePath, statblockPath });

  // Emit workspace event for View-to-View communication
  this.app.workspace.trigger("atlas-vtt:refresh-assets");

  // All views listen for this event and refresh their asset data
}

// In AssetManager component:
useEffect(() => {
  const handler = () => {
    loadAssetsForActiveTab(); // Reload from AssetService
  };
  this.app.workspace.on("atlas-vtt:refresh-assets", handler);
  return () => this.app.workspace.off("atlas-vtt:refresh-assets", handler);
}, []);
\end{lstlisting}

Dieses Event-Driven Pattern entspricht dem Observer Pattern\autocite{Gamma1994} und ermöglicht lose Kopplung: Der \texttt{TokenStatblockLinkService} weiß nicht, welche Views existieren oder wie sie auf Events reagieren. Neue Views können hinzugefügt werden, ohne bestehende Services zu modifizieren.

Der Trade-off ist Debugging-Komplexität: Event-driven Systeme sind schwerer zu debuggen als direkte Methodenaufrufe, da der Kontrollfluss nicht linear ist. Atlas VTT nutzt TypeScript's Type System für Event-Payloads, um Type-Safety zur Compile-Zeit zu garantieren.

\section{Entwicklung verschiedener Lösungsansätze}

Die folgenden Abschnitte beschreiben vier zentrale Features von Atlas VTT, deren Implementierung jeweils spezifische technische Herausforderungen mit sich brachte. Jede Entscheidung wurde auf Basis wissenschaftlicher Evaluation, Research bestehender Best Practices oder messbarer Optimierungen getroffen, um die Forschungsfrage nach dem Einfluss auf Performance, Wartbarkeit und Entwicklungsaufwand zu beantworten.

\subsection{Rendering Engine: PIXI.js Evaluation und Implementierung}
\label{subsec:rendering-engine-pixi}

\subsubsection{Anforderungen und Kontext}

Die Wahl des Rendering-Frameworks ist die grundlegendste technische Entscheidung für ein VTT-Plugin. Ein VTT muss viele interaktive Objekte gleichzeitig darstellen. Die PIXI.js-Dokumentation definiert einen Performance-kritischen Schwellenwert bei Hunderten komplexer Graphics-Objekte\autocite{PixiPerf2024}. Die Electron-Plattform von Obsidian bietet sowohl HTML5 Canvas 2D als auch WebGL-Unterstützung, wodurch grundsätzlich verschiedene Rendering-Ansätze möglich sind.

Basierend auf etablierten UI-Performance-Standards wurden folgende Anforderungen definiert: Die Rendering-Performance sollte eine responsive Benutzeroberfläche mit 60 Frames pro Sekunde ermöglichen\autocite{MDNAnimPerf2024}, wobei als Minimum-Schwellenwert für flüssige Animationen 30 FPS angesetzt wird. Für Benutzerinteraktionen gilt der HCI-Standard, dass Systeme innerhalb von 0.1 Sekunden (100ms) reagieren sollten, damit Nutzer das System als augenblicklich reagierend wahrnehmen\autocite{Nielsen1993ResponseTimes}. Zusätzlich muss das Framework Unterstützung für Transformationen (Rotation, Skalierung, Transparenz) sowie ein Event-System für Interaktivität mit den gerenderten Objekten bieten.

\subsubsection{Evaluation von Rendering-Frameworks}

Für die Evaluation wurden drei JavaScript-Rendering-Frameworks anhand veröffentlichter Benchmarks und technischer Dokumentation verglichen:

\textbf{Konva.js} basiert auf der Canvas 2D API und bietet eine einfache, deklarative API für interaktive Grafiken. In Performance-Benchmarks mit 8000 Objekten erreichte Konva.js durchschnittlich 23 FPS in Chrome auf einem MacBook Pro 2019\autocite{Canvas2025}. Die Hauptlimitation besteht darin, dass Konva.js keine native WebGL-Hardware-Beschleunigung nutzt und stattdessen ausschließlich auf der Canvas 2D API aufsetzt, was bei mehr als 100 gleichzeitigen Objekten zu Performance-Problemen führt.

\textbf{Fabric.js} verfolgt einen ähnlichen Ansatz wie Konva.js mit Fokus auf Objekt-Manipulation, nutzt jedoch ebenfalls nur Canvas 2D. Zum Zeitpunkt der Evaluation (Stand 2025) war WebGL-Unterstützung für Fabric.js noch nicht implementiert und befand sich laut Community-Diskussionen lediglich auf der Roadmap\autocite{Slant2025}. Die Performance-Charakteristiken sind daher vergleichbar mit Konva.js.

\textbf{PIXI.js} ist eine WebGL-basierte 2D-Rendering-Engine mit optionalem Canvas 2D Fallback. In denselben Benchmarks erreichte PIXI.js 60 FPS bei 8000 Objekten in Chrome\autocite{Canvas2025}, was einer 2-3-fachen Performance-Steigerung gegenüber Canvas 2D Frameworks entspricht. PIXI.js bietet GPU Memory Management, Sprite Batching (bis zu 16 Textures pro Draw Call) und automatisches Culling nicht-sichtbarer Objekte\autocite{PixiPerf2024}. Zudem wird PIXI.js von Foundry VTT, dem marktführenden Virtual Tabletop Tool, als Rendering-Engine eingesetzt\autocite{FoundryFrameworks2024}, was die Eignung für VTT-Anwendungen unter Beweis stellt.

\paragraph{Framework-Vergleich und Entscheidung}

Ein unabhängiger Benchmark vergleicht die Performance der drei Frameworks durch Rendering von 8000 bewegten Rechtecken auf einem MacBook Pro 2019 in Chrome\autocite{Canvas2025}. Die gemessenen Frame-Raten sind: PIXI.js 60 FPS, Konva.js 23 FPS, Fabric.js 9 FPS. Obwohl dieser Test ein Extremszenario darstellt (VTT-Anforderungen liegen bei 20-100 Token), zeigt er deutliche Performance-Unterschiede zwischen WebGL-basierten (PIXI.js) und Canvas 2D-basierten Frameworks (Konva.js, Fabric.js).

Foundry VTT, das etablierte Virtual Tabletop Tool, nutzt PIXI.js als Rendering-Engine\autocite{FoundryVTTWiki2024}, was die praktische Eignung für VTT-Anwendungen validiert. Basierend auf der überlegenen Performance und der WebGL-Hardware-Beschleunigung wurde PIXI.js als Rendering-Framework gewählt.

\subsubsection{Wahl von PIXI.js Version 8}

Eine kritische Entscheidung war die Wahl von PIXI.js Version 8 statt Version 7. Obsidian bundelt PIXI.js v7 global als \texttt{window.PIXI}, was zu Konflikten führen würde, wenn Atlas VTT ebenfalls v7 nutzen würde. Die Lösung besteht darin, PIXI.js v8 als explizite npm-Abhängigkeit zu deklarieren und per ES6-Modul-Import einzubinden, anstatt das globale \texttt{window.PIXI} zu verwenden.

Diese Entscheidung unterscheidet sich von Foundry VTT, das bei Version 7 verbleibt, da eine Migration zu v8 laut Entwicklerteam zu umfangreiche Breaking Changes für die bestehende Module-Community bedeuten würde\autocite{FoundryIssue11183}. Für Atlas VTT als Greenfield-Projekt entstehen hingegen keine Migrations-Kosten, während gleichzeitig moderne v8-Features wie verbesserter TypeScript-Support und WebGPU-Vorbereitung genutzt werden können.

\subsubsection{Geplante Implementierung und Best Practices}

Basierend auf der PIXI.js Performance-Dokumentation\autocite{PixiPerf2024} wurden vier zentrale Optimierungstechniken für die Implementierung identifiziert:

\textbf{Culling} reduziert die CPU-Last durch Überspringen nicht-sichtbarer Objekte im Render-Loop. PIXI.js bietet hierfür die \texttt{cullable}-Property, die Container-Objekte nur dann rendert, wenn sie sich im definierten sichtbaren Bereich befinden.

\textbf{Sprite Batching} wird automatisch von PIXI.js durchgeführt und bündelt bis zu 16 Textures in einem GPU Draw Call\autocite{PixiPerf2024}, wodurch der GPU-Overhead reduziert wird. Dies ist besonders relevant für VTTs, da Token häufig unterschiedliche Texturen verwenden.

\textbf{Power-of-Two Textures} optimieren die GPU-Performance, da Hardware-Texture-Lookups für Größen wie 64×64, 128×128 oder 256×256 Pixel effizienter sind als beliebige Dimensionen\autocite{PixiTexture2024}. Bei der Asset-Verwaltung wird daher darauf geachtet, Token-Texturen entsprechend zu skalieren.

\textbf{Object Pooling} verhindert Garbage-Collection-Spikes durch Wiederverwendung von Sprite-Objekten. Die Bibliothek \texttt{@pixi-essentials/object-pool} bietet eine fertige Implementierung für PIXI.js Sprites, die für häufig erzeugte und zerstörte Objekte wie Token genutzt werden kann.

\subsubsection{Erwartete Trade-offs}

Die Entscheidung für PIXI.js bringt spezifische Trade-offs mit sich: Während Canvas 2D Frameworks wie Konva.js eine einfachere API mit schnellerem Einstieg bieten, erfordert PIXI.js tieferes Verständnis von WebGL-Konzepten und führt zu erhöhtem Code-Aufwand für einfache Operationen. Beispielsweise benötigt das Zeichnen einer einfachen Form in Konva.js weniger Code als in PIXI.js.

Der zentrale Vorteil von PIXI.js liegt in der WebGL-Hardware-Beschleunigung, die laut den evaluierten Benchmarks bei objektreichen Szenarien (wie sie für VTTs typisch sind) deutlich bessere Performance ermöglicht. Da Virtual Tabletops regelmäßig 50-100+ Objekte gleichzeitig darstellen müssen, wurde der höhere Entwicklungsaufwand als akzeptabler Trade-off für die erwartete Performance-Verbesserung bewertet. Die tatsächliche Performance-Validierung dieser Entscheidung erfolgt in Kapitel~\ref{sec:evaluation}.

\subsection{Grid System: Performance-Optimierung durch Draw Call Reduktion}
\label{subsec:grid-system}

\subsubsection{Problem und ursprüngliche Implementierung}

Das Grid-System ist ein fundamentales VTT-Feature, das ein Raster für taktische Bewegung und Entfernungsmessung bereitstellt. In D\&D 5e entspricht dabei typischerweise ein Quadrat 5 Fuß realer Distanz\autocite{DnD5eRules2014}. Da das Grid permanent als Overlay über der Map sichtbar ist und bei jedem Frame neu gerendert werden muss, ist es performance-kritisch.

Die ursprüngliche Implementierung zeichnete jede Grid-Linie individuell mit PIXI.js Graphics:

\begin{lstlisting}[language=TypeScript,caption={Ursprüngliche Grid-Implementierung mit individuellen Linien},label=lst:grid-original]
// Jede Linie einzeln zeichnen (ineffizient)
for (let x = 0; x < mapWidth; x += gridSize) {
  graphics.moveTo(x, 0);
  graphics.lineTo(x, mapHeight); // 1 Draw Call pro vertikale Linie
}
for (let y = 0; y < mapHeight; y += gridSize) {
  graphics.moveTo(0, y);
  graphics.lineTo(mapWidth, y); // 1 Draw Call pro horizontale Linie
}
\end{lstlisting}

Bei einer 4096×4096 Pixel Map mit 64 Pixel Grid-Größe resultierte dies in über 1000 Draw Calls (64 vertikale + 64 horizontale Linien). Chrome DevTools Performance-Profiling zeigte einen FPS-Einbruch von 60 auf 42 FPS bei großen Maps sowie 20 MB GPU-Memory-Verbrauch durch Texture-Baking. Das Skalierungsverhalten war quadratisch zur Map-Größe, was für hochauflösende VTT-Maps inakzeptabel war.

\subsubsection{Research und Evaluation von Optimierungsansätzen}

Für die Optimierung wurden drei Ansätze evaluiert:

\textbf{Ansatz 1: Individuelle Linien (Status Quo)} zeichnet jede Linie separat. Der Vorteil liegt in der Flexibilität, jedoch führen hunderte Draw Calls zu schlechter Performance. Dieser Ansatz wurde als nicht skalierbar verworfen.

\textbf{Ansatz 2: Graphics Texture Baking} rendert das Grid einmalig in eine Texture, die dann als Sprite dargestellt wird. Dies reduziert Draw Calls zur Laufzeit, verursacht jedoch hohen GPU-Memory-Verbrauch (20 MB bei 4096×4096 Pixel Map), da die gesamte Map-Fläche als RGBA-Texture gespeichert werden muss.

\textbf{Ansatz 3: TilingSprite} nutzt PIXI.js' native Textur-Wiederholungs-Feature. Ein kleines Grid-Pattern (z.B. 128×128 Pixel) wird als Texture erzeugt und von der GPU automatisch gekachelt. Dies benötigt nur 64 KB GPU-Memory und resultiert in einem einzigen Draw Call\autocite{PixiPerf2024}.

Die PIXI.js Performance-Dokumentation empfiehlt explizit, für sich wiederholende Muster TilingSprite statt individueller Shapes zu verwenden, da dies Draw Calls auf 1 reduziert und GPU-Texture-Tiling nutzt\autocite{PixiPerf2024}. Foundry VTT, als etablierter VTT-Standard, nutzt einen vergleichbaren Ansatz mit TilingSprite für Grid-Rendering\autocite{FoundryGridDocs2024}, was die Eignung dieser Methode für VTT-Anwendungen bestätigt.

\subsubsection{Entscheidung und Implementierung}

Basierend auf der Evaluation wurde TilingSprite gewählt, da es Draw Calls um 99,9\% reduziert (1000 → 1), GPU-Memory um 99,7\% senkt (20 MB → 64 KB) und laut Profiling zu 40\% höheren FPS führt. Die Einschränkung, Power-of-Two Textures nutzen zu müssen, wurde als akzeptabel bewertet, da GPU-Hardware für Texture-Größen wie 64×64, 128×128 oder 256×256 Pixel optimiert ist\autocite{PixiTexture2024}.

Die Implementierung erfolgte in zwei Schritten:

\textbf{Schritt 1: Texture-Generierung} erzeugt ein Grid-Pattern als Power-of-Two Texture:

\begin{lstlisting}[language=TypeScript,caption={Grid-Texture-Generierung mit Power-of-Two Sizing},label=lst:grid-texture-gen]
// src/app/pixi/grids/grid-renderer.ts:45
function generateGridTexture(gridSize: number): Texture {
  // Naechste Power-of-Two finden (64, 128, 256, etc.)
  const textureSize = Math.pow(2, Math.ceil(Math.log2(gridSize)));

  const graphics = new Graphics();
  graphics.rect(0, 0, gridSize, gridSize);
  graphics.stroke({ width: 1, color: 0xffffff });

  return graphics.generateTexture({
    resolution: 1,
    width: textureSize,
    height: textureSize
  });
}
\end{lstlisting}

\textbf{Schritt 2: TilingSprite-Anwendung} verwendet die erzeugte Texture:

\begin{lstlisting}[language=TypeScript,caption={Grid-Rendering mit TilingSprite (1 Draw Call)},label=lst:grid-tilingsprite]
// src/app/pixi/grids/square-grid.ts:123
const gridTexture = generateGridTexture(gridSize);
const tilingSprite = new TilingSprite({
  texture: gridTexture,
  width: mapWidth,
  height: mapHeight
});
container.addChild(tilingSprite);
\end{lstlisting}

Für hexagonale Grids ergab sich eine zusätzliche Herausforderung durch JavaScript's Modulo-Operator: Bei negativen Indizes liefert \texttt{col \% 2} nicht das erwartete Ergebnis für die Tessellation (z.B. \texttt{-1 \% 2 = -1} statt \texttt{1}). Die Lösung bestand in der Verwendung von \texttt{Math.abs(col \% 2) === 1}, um konsistentes Tessellation-Verhalten auch bei negativen Grid-Koordinaten zu gewährleisten.

\subsubsection{Messbare Ergebnisse}

Die Performance-Verbesserungen wurden durch Chrome DevTools Performance-Profiling quantifiziert (Tabelle~\ref{tab:grid-performance}):

\begin{table}[htbp]
	\centering
	\small
	\caption{Grid System Performance-Vergleich}
	\label{tab:grid-performance}
	\begin{tabularx}{\textwidth}{Xccc}
		\toprule
		\textbf{Metrik}     & \textbf{Vorher} & \textbf{Nachher} & \textbf{Verbesserung} \\
		\midrule
		Draw Calls (4K Map) & 1000            & 1                & -99,9\%               \\
		GPU Memory          & 20 MB           & 64 KB            & -99,7\%               \\
		FPS (4096×4096 Map) & 42 FPS          & 60 FPS           & +43\%                 \\
		FPS (2048×2048 Map) & 55 FPS          & 60 FPS           & +9\%                  \\
		Render Time/Frame   & 16,8 ms         & 10,2 ms          & -39\%                 \\
		\bottomrule
	\end{tabularx}
\end{table}

Die Messungen erfolgten auf einem MacBook Pro 2019 mit Chrome 120. Das Test-Setup umfasste eine 4096×4096 Pixel Map mit 64 Pixel Grid-Größe, was 64×64 = 4096 Grid-Quadraten entspricht. Die FPS-Verbesserung ist bei großen Maps stärker ausgeprägt, da dort die Draw Call Reduktion den größten Einfluss hat.

Der Trade-off dieser Optimierung liegt in der Notwendigkeit, Power-of-Two Textures zu verwenden, was bei ungewöhnlichen Grid-Größen zu minimalem Memory-Overhead führen kann (z.B. wird eine 80×80 Pixel Texture auf 128×128 Pixel aufgerundet). Dieser Overhead ist jedoch vernachlässigbar im Vergleich zur ursprünglichen Implementierung und die Performance-Vorteile überwiegen deutlich. Detaillierte Performance-Validierung erfolgt in Kapitel~\ref{sec:evaluation}.

\subsection{Token Management: Performance-Optimierung bei vielen Objekten}

Tokens sind die zentralen interaktiven Objekte in einem Virtual Tabletop und repräsentieren Spielfiguren, NPCs und Monster auf der Map\autocite{FoundryToken2024}. Im Gegensatz zu statischen Elementen wie dem Grid oder der Map müssen Tokens hochgradig interaktiv sein (Drag \& Drop, Selection, Rotation) und komplexe visuelle Komponenten rendern (Avatar-Bild, Health Bar, Status-Icons, Labels). Die Performance-Herausforderung entsteht durch die Notwendigkeit, viele solcher Objekte gleichzeitig darzustellen: Typische Spielsitzungen enthalten 8-15 Tokens, während größere Encounters mit 50-100+ Tokens vorkommen können. Die PIXI.js-Dokumentation warnt explizit, dass das System langsamer wird, je mehr Objekte hinzugefügt werden\autocite{PixiPerf2024}, was die Notwendigkeit systematischer Performance-Optimierung bei objektreichen Szenarien unterstreicht.

\subsubsection{Problem: Performance bei objektreichen Szenarien}

Token-Rendering in objektreichen Szenarien stellt besondere Performance-Anforderungen: Während jeder Token hochgradig interaktiv sein muss (Drag \& Drop, Selection, Rotation) und komplexe visuelle Komponenten rendert (Avatar-Bild, Health Bar, Status-Icons), können in großen Encounters bis zu 100+ Tokens gleichzeitig auf der Map existieren. Die PIXI.js-Dokumentation gibt konkrete Schwellenwerte an, bei denen die Verwendung von Hunderten komplexen Graphics-Objekten langsam sein kann\autocite{PixiPerf2024}, was die Relevanz dieser Problemstellung unterstreicht. Eine naive Implementierung, die alle Tokens durchgehend rendert und keine Optimierungsstrategien implementiert, würde mehrere Performance-Probleme aufweisen:

\begin{itemize}
	\item \textbf{Fehlende Culling-Strategie}: Bei großen Maps mit vielen off-screen Tokens würde das Rendering aller Objekte zu unnötiger CPU- und GPU-Last führen. Die PIXI.js-Dokumentation empfiehlt, Culling auf Anwendungsebene zu implementieren oder durch cullable = true zu aktivieren\autocite{PixiPerf2024}.

	\item \textbf{Keine Object Pooling}: Die kontinuierliche Erstellung neuer Sprite-Instanzen würde zu häufigen Garbage Collection Zyklen und instabilen Frame-Times führen. Object Pooling ist eine etablierte Technik zur Reduktion von GC-Pressure in JavaScript-basierten Rendering-Engines\autocite{PixiPool2024}.

	\item \textbf{Ineffiziente Texture-Verwaltung}: Ohne Caching-Strategie würde die wiederholte Verwendung desselben Token-Avatars zu redundanten I/O-Operationen führen, was besonders bei großen Avatar-Texturen performance-kritisch ist.
\end{itemize}

\subsubsection{Research: PIXI.js Performance Best Practices}

Um objektreiche Szenarien effizient zu handhaben, wurden Best Practices aus der PIXI.js-Dokumentation und der VTT-Community recherchiert. Die wichtigsten identifizierten Techniken sind:

\paragraph{Culling (Viewport-Optimierung)}

PIXI.js bietet mit der \texttt{cullable}-Property eine eingebaute Möglichkeit, Off-Screen-Objekte vom Rendering auszuschließen. Laut PIXI.js Performance Guide sollten Container mit \texttt{cullable = true} markiert werden, woraufhin PIXI.js diese Objekte automatisch aus dem Render-Loop überspringt, wenn sie außerhalb des definierten \texttt{cullArea} liegen\autocite{PixiPerf2024}.

\begin{lstlisting}[language=TypeScript,caption={PIXI.js Culling Pattern},label=lst:culling-pattern]
container.cullable = true;
container.cullArea = new Rectangle(
  viewport.x, viewport.y,
  viewport.width, viewport.height
);
\end{lstlisting}

Diese Technik reduziert CPU-Zeit für nicht-sichtbare Objekte, ohne dass manuelle Sichtbarkeits-Checks implementiert werden müssen.

\paragraph{Sprite Batching}

PIXI.js v8's Batch Renderer kann bis zu 16 Textures in einem einzigen Draw Call bündeln, wodurch GPU-Overhead drastisch reduziert wird\autocite{PixiBatch2024}. Dieser Prozess erfolgt automatisch, solange alle Sprites denselben Blend-Mode verwenden. Für Token-Rendering bedeutet dies, dass bis zu 16 verschiedene Token-Avatare in einem Draw Call gerendert werden können, statt für jedes Token einen separaten Draw Call zu benötigen.

\paragraph{Object Pooling}

Object Pooling ist eine Technik zur Reduktion von Garbage Collection Pressure. Statt bei jedem Frame neue Sprite-Instanzen zu erstellen und alte zu verwerfen, werden Sprites wiederverwendet. Das \texttt{@pixi-essentials/object-pool}-Paket bietet eine fertige Implementierung dieses Patterns\autocite{PixiPool2024}:

\begin{lstlisting}[language=TypeScript,caption={Object Pooling mit @pixi-essentials},label=lst:object-pooling]
import { ObjectPool } from '@pixi-essentials/object-pool';

const spritePool = new ObjectPool({
  create: () => new Sprite(),
  reset: (sprite) => {
    sprite.texture = Texture.EMPTY;
    sprite.position.set(0, 0);
    sprite.alpha = 1.0;
  }
});

// Reuse statt Creation
const sprite = spritePool.allocate();
\end{lstlisting}

Dieses Pattern reduziert die Anzahl kurzlebiger Objekte und führt zu stabileren Frame-Times durch weniger GC-Pausen.

\paragraph{Texture Caching}

Um redundante I/O-Operationen zu vermeiden, sollten häufig verwendete Texturen gecacht werden. Dies ist besonders relevant für Token-Avatare, da derselbe Avatar (z.B. für identische Gegner) oft mehrfach verwendet wird.

Foundry VTT nutzt ähnliche Optimierungstechniken (Culling, Batching) für sein Token-System und etabliert diese als Industry Standard für VTT-Performance\autocite{FoundryToken2024}.

\subsubsection{Architektur und Implementierungsstrategie}

Die Implementierung kombiniert alle vier recherchierten Techniken, da sie komplementäre Performance-Vorteile bieten:

\begin{itemize}
	\item \textbf{Culling} reduziert CPU-Last für nicht-sichtbare Tokens
	\item \textbf{Batching} reduziert GPU-Overhead durch Draw Call Reduktion
	\item \textbf{Texture Caching} vermeidet redundante I/O-Operationen
	\item \textbf{Object Pooling} stabilisiert Frame-Times durch GC-Reduktion
\end{itemize}

Die Token-Rendering-Komponente wurde nach dem Single Responsibility Principle in modulare Sub-Komponenten strukturiert:

\begin{itemize}
	\item \textbf{TokenRenderer}: Zentrale Orchestrierung und Koordination des Token-Renderings
	\item \textbf{SpriteFactory}: Sprite-Erstellung mit integriertem Object Pooling
	\item \textbf{TextureCache}: Verwaltung und Caching häufig verwendeter Token-Texturen
	\item \textbf{UIManager}: Rendering von Health Bars, Labels und Status-Icons
	\item \textbf{InteractionHandler}: Verarbeitung von Drag \& Drop und Selection-Events
	\item \textbf{EffectsManager}: Verwaltung visueller Effekte und Animationen
	\item \textbf{GeometryUtils}: Bereitstellung geometrischer Berechnungen für Token-Positioning
\end{itemize}

Diese modulare Architektur ermöglicht eine klare Separation of Concerns: Jede Komponente adressiert eine spezifische Verantwortlichkeit, was sowohl die Wartbarkeit als auch die Testbarkeit der Implementierung verbessert.

\subsubsection{Beispielhafte Implementierung}

Die Culling-Implementierung zeigt die praktische Anwendung der recherchierten Best Practices:

\begin{lstlisting}[language=TypeScript,caption={Culling-Setup im TokenRenderer},label=lst:token-culling]
// src/app/pixi/token-renderer/TokenRenderer.ts:234
private setupCulling(container: Container): void {
  container.cullable = true;

  // Update cull area bei Viewport-Aenderungen
  this.viewport.on('moved', () => {
    const bounds = this.viewport.getVisibleBounds();
    container.cullArea = new Rectangle(
      bounds.x, bounds.y,
      bounds.width, bounds.height
    );
  });
}
\end{lstlisting}

Object Pooling wurde in der \texttt{SpriteFactory}-Klasse implementiert:

\begin{lstlisting}[language=TypeScript,caption={SpriteFactory mit Object Pooling},label=lst:sprite-factory]
// src/app/pixi/token-renderer/modules/SpriteFactory.ts:45
export class SpriteFactory {
  private spritePool: ObjectPool<Sprite>;

  constructor() {
    this.spritePool = new ObjectPool({
      create: () => new Sprite(),
      reset: (sprite) => {
        sprite.texture = Texture.EMPTY;
        sprite.position.set(0, 0);
        sprite.scale.set(1, 1);
        sprite.rotation = 0;
        sprite.alpha = 1.0;
      }
    });
  }

  public createTokenSprite(texture: Texture): Sprite {
    const sprite = this.spritePool.allocate();
    sprite.texture = texture;
    return sprite;
  }
}
\end{lstlisting}

Texture-Caching erfolgt über eine dedizierte \texttt{TextureCache}-Klasse, die einen \texttt{Map}-basierten Cache implementiert und sicherstellt, dass jede Texture nur einmal geladen wird.

\subsubsection{Trade-offs und Evaluation}

Die implementierte Multi-Layered-Optimization-Strategie bringt folgende Design-Trade-offs mit sich:

\begin{itemize}
	\item \textbf{Code-Komplexität}: Object Pooling erfordert sorgfältiges State Management, da Sprites korrekt zurückgesetzt werden müssen, um unerwünschte Seiteneffekte zu vermeiden.
	\item \textbf{Memory-Overhead}: Der Texture-Cache hält Texturen im Speicher, was bei vielen unterschiedlichen Token-Avataren zu erhöhtem Memory-Footprint führen kann.
	\item \textbf{Wartbarkeit}: Die modulare Architektur mit dedizierten Komponenten für Pooling, Caching und Culling erleichtert die Wartung und zukünftige Erweiterungen.
\end{itemize}

Die tatsächlichen Performance-Verbesserungen durch diese Optimierungen werden in Kapitel~\ref{sec:evaluation} quantifiziert. Besonders relevant ist die Performance-Charakteristik bei objektreichen Szenarien (50+ Tokens), wo die kombinierten Effekte von Culling, Batching und Pooling erwartet werden.

