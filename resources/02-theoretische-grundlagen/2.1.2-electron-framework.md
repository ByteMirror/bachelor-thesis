# 2.1.2 Electron Framework

## Kontext und Planung

### Kernthema
Electron als technische Basis von Obsidian und dessen Auswirkungen auf Plugin-Performance, speziell für grafikintensive Anwendungen wie Atlas VTT.

### Ziel des Abschnitts
Verständnis der Electron-Architektur und deren Performance-Charakteristika als Grundlage für Optimierungsstrategien.

## Inhaltliche Struktur

### Electron Übersicht (1-2 Absätze)
- Cross-Platform Desktop Framework
- Chromium + Node.js Kombination
- Web-Technologien für Desktop-Apps
- Verwendung in populären Apps (VS Code, Discord, Slack)

### Architektur (2-3 Absätze)
**Process Model:**
```
Main Process (Node.js)
    ├── File System Access
    ├── Native APIs
    └── Window Management

Renderer Process(es) (Chromium)
    ├── Web Content
    ├── DOM/CSS
    └── JavaScript V8
```

**IPC (Inter-Process Communication):**
- Synchrone vs. Asynchrone Kommunikation
- Message Passing Overhead
- Context Bridge für sichere Kommunikation
- Performance-Implikationen

### Renderer Process Details (2-3 Absätze)
**Chromium Engine:**
- Blink Rendering Engine
- V8 JavaScript Engine
- Compositing und GPU-Beschleunigung
- WebGL/WebGPU Support

**Event Loop und Threading:**
- Single-threaded JavaScript
- Web Workers für Parallelisierung
- RAF (requestAnimationFrame) für Animationen
- Micro/Macro Task Queue

### Memory Management (2-3 Absätze)
**Heap Management:**
- V8 Garbage Collection
- Memory Limits (typ. 512MB - 4GB)
- Memory Leaks in SPAs
- Chrome DevTools Profiling

**GPU Memory:**
- Texture Memory Management
- WebGL Context Limits
- Canvas Memory Overhead
- SharedArrayBuffer Restrictions

### Performance-Charakteristika (2-3 Absätze)
**Vorteile:**
- Hardware-Beschleunigung
- Moderne Web-APIs
- Chrome DevTools Integration
- Hot Reload Development

**Nachteile:**
- Memory Overhead (Chromium + Node.js)
- Startup Time
- Bundle Size
- CPU Usage vs Native Apps

### Optimierungsmöglichkeiten (1-2 Absätze)
**Electron-spezifisch:**
- BrowserWindow Optionen
- webPreferences Tuning
- Hardware Acceleration Settings
- Process Pooling

**Web-Performance:**
- Code Splitting
- Lazy Loading
- Virtual Scrolling
- Web Workers

## Relevanz für Atlas VTT

### Performance-Bottlenecks
1. **Rendering Pipeline:**
   - DOM Updates vs Canvas/WebGL
   - Compositor Thread Auslastung
   - Paint/Layout Thrashing

2. **Memory Constraints:**
   - Texture Memory für Maps
   - Sprite/Asset Caching
   - JavaScript Heap Size

3. **Event Processing:**
   - Input Event Latency
   - Event Bubble/Capture Overhead
   - Touch vs Mouse Performance

### Optimierungspotenziale
- OffscreenCanvas für Background Rendering
- WebGL für Hardware-Acceleration
- IndexedDB für Asset-Caching
- Service Workers für Resource-Loading

## Code-Beispiele und Konzepte

### Performance-Monitoring
```javascript
// Frame-Time Measurement
let lastTime = performance.now();
function measureFrame() {
  const now = performance.now();
  const frameTime = now - lastTime;
  if (frameTime > 16.67) { // Target: 60 FPS
    console.warn(`Slow frame: ${frameTime}ms`);
  }
  lastTime = now;
  requestAnimationFrame(measureFrame);
}
```

### Memory-Profiling
```javascript
if (performance.memory) {
  console.log({
    usedJSHeapSize: performance.memory.usedJSHeapSize,
    totalJSHeapSize: performance.memory.totalJSHeapSize,
    jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
  });
}
```

## Literatur und Quellen

### Primärquellen
- [ ] Electron Documentation
- [ ] Chromium Design Documents
- [ ] V8 Performance Guides

### Performance-Studien
- [ ] Electron vs Native Performance
- [ ] WebGL in Electron Apps
- [ ] Memory Usage Studies

### Best Practices
- [ ] Electron Security & Performance
- [ ] Chrome DevTools Guides
- [ ] Web Performance APIs

## Schreibnotizen

### Wichtige Begriffe
- Main Process: Node.js Hauptprozess
- Renderer Process: Chromium Web-Prozess
- IPC: Inter-Process Communication
- Context Isolation: Sicherheitsfeature
- Preload Script: Bridge zwischen Prozessen

### Fokus
- Performance-relevante Aspekte
- Keine allgemeine Electron-Einführung
- Bezug zu Grafikanwendungen
- Messbare Metriken

### Abgrenzung
- Kein Electron-Tutorial
- Fokus auf Performance
- Obsidian-Kontext beachten
- VTT-Relevanz hervorheben

## Verbindung zu anderen Kapiteln
- ← 2.1.1: Obsidian basiert auf Electron
- → 2.3.1: Performance-Metriken
- → 3.3: Lösungsansätze (Canvas/WebGL)
- → 4.1: Test-Umgebung Setup

## TODO beim Schreiben
- [ ] Electron-Version in Obsidian ermitteln
- [ ] Chromium-Version spezifizieren
- [ ] Memory-Limits quantifizieren
- [ ] Performance-Vergleiche zitieren
- [ ] GPU-Acceleration Details